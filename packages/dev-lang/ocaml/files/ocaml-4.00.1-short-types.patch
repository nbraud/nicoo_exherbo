Source: https://yquem.inria.fr/caml/svn/ocaml/branches/short-paths
Upstream: Yes (in an experimental branch)
Reason: Use J. Garrigue's patch to the type pretty-printer

---
 driver/compile.ml                     |    8 +-
 driver/errors.ml                      |   12 +-
 driver/main.ml                        |    1 +
 driver/main_args.ml                   |   12 ++
 driver/main_args.mli                  |    4 +
 driver/opterrors.ml                   |   12 +-
 driver/optmain.ml                     |    1 +
 ocamldoc/odoc_analyse.ml              |   12 +-
 otherlibs/labltk/browser/searchid.ml  |    2 +-
 otherlibs/labltk/browser/searchpos.ml |   28 +++--
 otherlibs/labltk/browser/typecheck.ml |   12 +-
 tools/ocamlcp.ml                      |    1 +
 tools/ocamloptp.ml                    |    1 +
 toplevel/opttopmain.ml                |    1 +
 toplevel/toploop.ml                   |   15 +--
 toplevel/topmain.ml                   |    1 +
 typing/ctype.ml                       |   32 +++---
 typing/ctype.mli                      |   10 +-
 typing/env.ml                         |   22 ++++
 typing/env.mli                        |    1 +
 typing/ident.ml                       |    5 +
 typing/ident.mli                      |    1 +
 typing/includeclass.ml                |   39 ++++---
 typing/includemod.ml                  |   39 ++++---
 typing/includemod.mli                 |    2 +-
 typing/printtyp.ml                    |  198 ++++++++++++++++++++++++++-------
 typing/printtyp.mli                   |   13 ++-
 typing/stypes.ml                      |    6 +-
 typing/typeclass.ml                   |   93 +++++++++-------
 typing/typeclass.mli                  |    4 +-
 typing/typecore.ml                    |  119 +++++++++++---------
 typing/typecore.mli                   |    4 +-
 typing/typedecl.ml                    |   20 ++--
 typing/typedecl.mli                   |    4 +-
 typing/typemod.ml                     |   62 ++++++-----
 typing/typemod.mli                    |    4 +-
 typing/typetexp.ml                    |   26 ++---
 typing/typetexp.mli                   |    2 +-
 utils/clflags.ml                      |    1 +
 utils/clflags.mli                     |    1 +
 40 files changed, 519 insertions(+), 312 deletions(-)

diff --git a/driver/compile.ml b/driver/compile.ml
index 5b79877..fdee2ee 100644
--- a/driver/compile.ml
+++ b/driver/compile.ml
@@ -86,11 +86,13 @@ let interface ppf sourcefile outputprefix =
     if !Clflags.dump_parsetree then fprintf ppf "%a@." Printast.interface ast;
     let tsg = Typemod.transl_signature initial_env ast in
     if !Clflags.print_types then
-      fprintf std_formatter "%a@." Printtyp.signature
-                                   (Typemod.simplify_signature tsg.sig_type);
+      Printtyp.wrap_printing_env initial_env (fun () ->
+        fprintf std_formatter "%a@."
+          Printtyp.signature (Typemod.simplify_signature tsg.sig_type));
     Warnings.check_fatal ();
     if not !Clflags.print_types then begin
-      let sg = Env.save_signature tsg.sig_type modulename (outputprefix ^ ".cmi") in
+      let sg =
+        Env.save_signature tsg.sig_type modulename (outputprefix ^ ".cmi") in
       Typemod.save_signature modulename tsg outputprefix sourcefile
        initial_env sg ;
     end;
diff --git a/driver/errors.ml b/driver/errors.ml
index 47ae995..dc49341 100644
--- a/driver/errors.ml
+++ b/driver/errors.ml
@@ -42,19 +42,19 @@ let report_error ppf exn =
       fprintf ppf
       "In this program,@ variant constructors@ `%s and `%s@ \
        have the same hash value.@ Change one of them." l l'
-  | Typecore.Error(loc, err) ->
-      Location.print_error ppf loc; Typecore.report_error ppf err
+  | Typecore.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typecore.report_error env ppf err
   | Typetexp.Error(loc, err) ->
       Location.print_error ppf loc; Typetexp.report_error ppf err
   | Typedecl.Error(loc, err) ->
       Location.print_error ppf loc; Typedecl.report_error ppf err
-  | Typeclass.Error(loc, err) ->
-      Location.print_error ppf loc; Typeclass.report_error ppf err
+  | Typeclass.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typeclass.report_error env ppf err
   | Includemod.Error err ->
       Location.print_error_cur_file ppf;
       Includemod.report_error ppf err
-  | Typemod.Error(loc, err) ->
-      Location.print_error ppf loc; Typemod.report_error ppf err
+  | Typemod.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typemod.report_error env ppf err
   | Translcore.Error(loc, err) ->
       Location.print_error ppf loc; Translcore.report_error ppf err
   | Translclass.Error(loc, err) ->
diff --git a/driver/main.ml b/driver/main.ml
index 9d448ba..068cfa9 100644
--- a/driver/main.ml
+++ b/driver/main.ml
@@ -122,6 +122,7 @@ module Options = Main_args.Make_bytecomp_options (struct
   let _pack = set make_package
   let _pp s = preprocessor := Some s
   let _principal = set principal
+  let _real_paths = set real_paths
   let _rectypes = set recursive_types
   let _runtime_variant s = runtime_variant := s
   let _strict_sequence = set strict_sequence
diff --git a/driver/main_args.ml b/driver/main_args.ml
index fa0b83f..5759b8a 100644
--- a/driver/main_args.ml
+++ b/driver/main_args.ml
@@ -213,6 +213,10 @@ let mk_principal f =
   "-principal", Arg.Unit f, " Check principality of type inference"
 ;;
 
+let mk_real_paths f =
+  "-real-paths", Arg.Unit f, " Do not shorten paths in types"
+;;
+
 let mk_rectypes f =
   "-rectypes", Arg.Unit f, " Allow arbitrary recursive types"
 ;;
@@ -429,6 +433,7 @@ module type Bytecomp_options = sig
   val _pack : unit -> unit
   val _pp : string -> unit
   val _principal : unit -> unit
+  val _real_paths : unit -> unit
   val _rectypes : unit -> unit
   val _runtime_variant : string -> unit
   val _strict_sequence : unit -> unit
@@ -467,6 +472,7 @@ module type Bytetop_options = sig
   val _nopromptcont : unit -> unit
   val _nostdlib : unit -> unit
   val _principal : unit -> unit
+  val _real_paths : unit -> unit
   val _rectypes : unit -> unit
   val _stdin: unit -> unit
   val _strict_sequence : unit -> unit
@@ -518,6 +524,7 @@ module type Optcomp_options = sig
   val _pack : unit -> unit
   val _pp : string -> unit
   val _principal : unit -> unit
+  val _real_paths : unit -> unit
   val _rectypes : unit -> unit
   val _runtime_variant : string -> unit
   val _S : unit -> unit
@@ -570,6 +577,7 @@ module type Opttop_options = sig
   val _nopromptcont : unit -> unit
   val _nostdlib : unit -> unit
   val _principal : unit -> unit
+  val _real_paths : unit -> unit
   val _rectypes : unit -> unit
   val _S : unit -> unit
   val _stdin : unit -> unit
@@ -645,6 +653,7 @@ struct
     mk_pack_byt F._pack;
     mk_pp F._pp;
     mk_principal F._principal;
+    mk_real_paths F._real_paths;
     mk_rectypes F._rectypes;
     mk_runtime_variant F._runtime_variant;
     mk_strict_sequence F._strict_sequence;
@@ -687,6 +696,7 @@ struct
     mk_nopromptcont F._nopromptcont;
     mk_nostdlib F._nostdlib;
     mk_principal F._principal;
+    mk_real_paths F._real_paths;
     mk_rectypes F._rectypes;
     mk_stdin F._stdin;
     mk_strict_sequence F._strict_sequence;
@@ -742,6 +752,7 @@ struct
     mk_pack_opt F._pack;
     mk_pp F._pp;
     mk_principal F._principal;
+    mk_real_paths F._real_paths;
     mk_rectypes F._rectypes;
     mk_runtime_variant F._runtime_variant;
     mk_S F._S;
@@ -796,6 +807,7 @@ module Make_opttop_options (F : Opttop_options) = struct
     mk_nopromptcont F._nopromptcont;
     mk_nostdlib F._nostdlib;
     mk_principal F._principal;
+    mk_real_paths F._real_paths;
     mk_rectypes F._rectypes;
     mk_S F._S;
     mk_stdin F._stdin;
diff --git a/driver/main_args.mli b/driver/main_args.mli
index b7984ca..251ec91 100644
--- a/driver/main_args.mli
+++ b/driver/main_args.mli
@@ -45,6 +45,7 @@ module type Bytecomp_options =
     val _pack : unit -> unit
     val _pp : string -> unit
     val _principal : unit -> unit
+    val _real_paths : unit -> unit
     val _rectypes : unit -> unit
     val _runtime_variant : string -> unit
     val _strict_sequence : unit -> unit
@@ -84,6 +85,7 @@ module type Bytetop_options = sig
   val _nopromptcont : unit -> unit
   val _nostdlib : unit -> unit
   val _principal : unit -> unit
+  val _real_paths : unit -> unit
   val _rectypes : unit -> unit
   val _stdin : unit -> unit
   val _strict_sequence : unit -> unit
@@ -135,6 +137,7 @@ module type Optcomp_options = sig
   val _pack : unit -> unit
   val _pp : string -> unit
   val _principal : unit -> unit
+  val _real_paths : unit -> unit
   val _rectypes : unit -> unit
   val _runtime_variant : string -> unit
   val _S : unit -> unit
@@ -187,6 +190,7 @@ module type Opttop_options = sig
   val _nopromptcont : unit -> unit
   val _nostdlib : unit -> unit
   val _principal : unit -> unit
+  val _real_paths : unit -> unit
   val _rectypes : unit -> unit
   val _S : unit -> unit
   val _stdin : unit -> unit
diff --git a/driver/opterrors.ml b/driver/opterrors.ml
index a30c2de..4078bbb 100644
--- a/driver/opterrors.ml
+++ b/driver/opterrors.ml
@@ -41,19 +41,19 @@ let report_error ppf exn =
       fprintf ppf
       "In this program,@ variant constructors@ `%s and `%s@ \
        have the same hash value.@ Change one of them." l l'
-  | Typecore.Error(loc, err) ->
-      Location.print_error ppf loc; Typecore.report_error ppf err
+  | Typecore.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typecore.report_error env ppf err
   | Typetexp.Error(loc, err) ->
       Location.print_error ppf loc; Typetexp.report_error ppf err
   | Typedecl.Error(loc, err) ->
       Location.print_error ppf loc; Typedecl.report_error ppf err
-  | Typeclass.Error(loc, err) ->
-      Location.print_error ppf loc; Typeclass.report_error ppf err
+  | Typeclass.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typeclass.report_error env ppf err
   | Includemod.Error err ->
       Location.print_error_cur_file ppf;
       Includemod.report_error ppf err
-  | Typemod.Error(loc, err) ->
-      Location.print_error ppf loc; Typemod.report_error ppf err
+  | Typemod.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typemod.report_error env ppf err
   | Translcore.Error(loc, err) ->
       Location.print_error ppf loc; Translcore.report_error ppf err
   | Translclass.Error(loc, err) ->
diff --git a/driver/optmain.ml b/driver/optmain.ml
index b6b86bb..4025b5c 100644
--- a/driver/optmain.ml
+++ b/driver/optmain.ml
@@ -133,6 +133,7 @@ module Options = Main_args.Make_optcomp_options (struct
   let _pack = set make_package
   let _pp s = preprocessor := Some s
   let _principal = set principal
+  let _real_paths = set real_paths
   let _rectypes = set recursive_types
   let _runtime_variant s = runtime_variant := s
   let _strict_sequence = set strict_sequence
diff --git a/ocamldoc/odoc_analyse.ml b/ocamldoc/odoc_analyse.ml
index d3b7bb0..a2a7dc6 100644
--- a/ocamldoc/odoc_analyse.ml
+++ b/ocamldoc/odoc_analyse.ml
@@ -175,8 +175,8 @@ let process_error exn =
       fprintf ppf
       "In this program,@ variant constructors@ `%s and `%s@ \
        have the same hash value." l l'
-  | Typecore.Error(loc, err) ->
-      Location.print_error ppf loc; Typecore.report_error ppf err
+  | Typecore.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typecore.report_error env ppf err
   | Typetexp.Error(loc, err) ->
       Location.print_error ppf loc; Typetexp.report_error ppf err
   | Typedecl.Error(loc, err) ->
@@ -184,15 +184,15 @@ let process_error exn =
   | Includemod.Error err ->
       Location.print_error_cur_file ppf;
       Includemod.report_error ppf err
-  | Typemod.Error(loc, err) ->
-      Location.print_error ppf loc; Typemod.report_error ppf err
+  | Typemod.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typemod.report_error env ppf err
   | Translcore.Error(loc, err) ->
       Location.print_error ppf loc; Translcore.report_error ppf err
   | Sys_error msg ->
       Location.print_error_cur_file ppf;
       fprintf ppf "I/O error: %s" msg
-  | Typeclass.Error(loc, err) ->
-      Location.print_error ppf loc; Typeclass.report_error ppf err
+  | Typeclass.Error(loc, env, err) ->
+      Location.print_error ppf loc; Typeclass.report_error env ppf err
   | Translclass.Error(loc, err) ->
       Location.print_error ppf loc; Translclass.report_error ppf err
   | Warnings.Errors (n) ->
diff --git a/otherlibs/labltk/browser/searchid.ml b/otherlibs/labltk/browser/searchid.ml
index ab66f0f..b714fe7 100644
--- a/otherlibs/labltk/browser/searchid.ml
+++ b/otherlibs/labltk/browser/searchid.ml
@@ -294,7 +294,7 @@ let search_string_type text ~mode =
         end in
       try (Typemod.transl_signature env sexp).sig_type
       with Env.Error err -> []
-      | Typemod.Error (l,_) ->
+      | Typemod.Error (l,_,_) ->
           let start_c = l.loc_start.Lexing.pos_cnum in
           let end_c = l.loc_end.Lexing.pos_cnum in
           raise (Error (start_c - 8, end_c - 8))
diff --git a/otherlibs/labltk/browser/searchpos.ml b/otherlibs/labltk/browser/searchpos.ml
index cf79d94..1383307 100644
--- a/otherlibs/labltk/browser/searchpos.ml
+++ b/otherlibs/labltk/browser/searchpos.ml
@@ -385,7 +385,8 @@ let rec view_signature ?title ?path ?(env = !start_env) ?(detach=false) sign =
       tl, tw, finish
   in
   Format.set_max_boxes 100;
-  Printtyp.signature Format.std_formatter sign;
+  Printtyp.wrap_printing_env env
+    (fun () -> Printtyp.signature Format.std_formatter sign);
   finish ();
   Lexical.init_tags tw;
   Lexical.tag tw;
@@ -532,16 +533,18 @@ and view_decl_menu lid ~kind ~env ~parent =
     Format.set_formatter_output_functions buf#out (fun () -> ());
     Format.set_margin 60;
     Format.open_hbox ();
-    if kind = `Type then
-      Printtyp.type_declaration
-        (ident_of_path path ~default:"t")
-        Format.std_formatter
-        (find_type path env)
-    else
-      Printtyp.modtype_declaration
-        (ident_of_path path ~default:"S")
-        Format.std_formatter
-        (find_modtype path env);
+    Printtyp.wrap_printing_env env begin fun () ->
+      if kind = `Type then
+        Printtyp.type_declaration
+          (ident_of_path path ~default:"t")
+          Format.std_formatter
+          (find_type path env)
+      else
+        Printtyp.modtype_declaration
+          (ident_of_path path ~default:"S")
+          Format.std_formatter
+          (find_modtype path env)
+    end;
     Format.close_box (); Format.print_flush ();
     Format.set_formatter_output_functions fo ff;
     Format.set_margin margin;
@@ -632,7 +635,8 @@ let view_type_menu kind ~env ~parent =
       Format.open_hbox ();
       Printtyp.reset ();
       Printtyp.mark_loops ty;
-      Printtyp.type_expr Format.std_formatter ty;
+      Printtyp.wrap_printing_env env
+        (fun () -> Printtyp.type_expr Format.std_formatter ty);
       Format.close_box (); Format.print_flush ();
       Format.set_formatter_output_functions fo ff;
       Format.set_margin margin;
diff --git a/otherlibs/labltk/browser/typecheck.ml b/otherlibs/labltk/browser/typecheck.ml
index f557105..0faa282 100644
--- a/otherlibs/labltk/browser/typecheck.ml
+++ b/otherlibs/labltk/browser/typecheck.ml
@@ -143,14 +143,14 @@ let f txt =
           | Syntaxerr.Variable_in_scope(l,_) -> l
           | Syntaxerr.Other l -> l
           end
-      | Typecore.Error (l,err) ->
-          Typecore.report_error Format.std_formatter err; l
-      | Typeclass.Error (l,err) ->
-          Typeclass.report_error Format.std_formatter err; l
+      | Typecore.Error (l, env, err) ->
+          Typecore.report_error env Format.std_formatter err; l
+      | Typeclass.Error (l, env, err) ->
+          Typeclass.report_error env Format.std_formatter err; l
       | Typedecl.Error (l, err) ->
           Typedecl.report_error Format.std_formatter err; l
-      | Typemod.Error (l,err) ->
-          Typemod.report_error Format.std_formatter err; l
+      | Typemod.Error (l, env, err) ->
+          Typemod.report_error env Format.std_formatter err; l
       | Typetexp.Error (l,err) ->
           Typetexp.report_error Format.std_formatter err; l
       | Includemod.Error errl ->
diff --git a/tools/ocamlcp.ml b/tools/ocamlcp.ml
index a6e8286..577eb56 100644
--- a/tools/ocamlcp.ml
+++ b/tools/ocamlcp.ml
@@ -74,6 +74,7 @@ module Options = Main_args.Make_bytecomp_options (struct
   let _pack = option "-pack"
   let _pp s = incompatible "-pp"
   let _principal = option "-principal"
+  let _real_paths = option "-real-paths"
   let _rectypes = option "-rectypes"
   let _runtime_variant s = option_with_arg "-runtime-variant" s
   let _strict_sequence = option "-strict-sequence"
diff --git a/tools/ocamloptp.ml b/tools/ocamloptp.ml
index 86400d9..74be227 100644
--- a/tools/ocamloptp.ml
+++ b/tools/ocamloptp.ml
@@ -77,6 +77,7 @@ module Options = Main_args.Make_optcomp_options (struct
   let _pack = option "-pack"
   let _pp s = incompatible "-pp"
   let _principal = option "-principal"
+  let _real_paths = option "-real-paths"
   let _rectypes = option "-rectypes"
   let _runtime_variant s = option_with_arg "-runtime-variant" s
   let _S = option "-S"
diff --git a/toplevel/opttopmain.ml b/toplevel/opttopmain.ml
index ac32a5c..ab7eeb0 100644
--- a/toplevel/opttopmain.ml
+++ b/toplevel/opttopmain.ml
@@ -77,6 +77,7 @@ module Options = Main_args.Make_opttop_options (struct
   let _nopromptcont = set nopromptcont
   let _nostdlib = set no_std_include
   let _principal = set principal
+  let _real_paths = set real_paths
   let _rectypes = set recursive_types
   let _strict_sequence = set strict_sequence
   let _S = set keep_asm_file
diff --git a/toplevel/toploop.ml b/toplevel/toploop.ml
index aa356b2..a974a90 100644
--- a/toplevel/toploop.ml
+++ b/toplevel/toploop.ml
@@ -231,13 +231,14 @@ let execute_phrase print_outcome ppf phr =
           match res with
           | Result v ->
               if print_outcome then
-                match str.str_items with
-                | [ { str_desc = Tstr_eval exp }] ->
-                    let outv = outval_of_value newenv v exp.exp_type in
-                    let ty = Printtyp.tree_of_type_scheme exp.exp_type in
-                    Ophr_eval (outv, ty)
-                | [] -> Ophr_signature []
-                | _ -> Ophr_signature (item_list newenv sg')
+                Printtyp.wrap_printing_env oldenv (fun () ->
+                  match str.str_items with
+                  | [ { str_desc = Tstr_eval exp }] ->
+                      let outv = outval_of_value newenv v exp.exp_type in
+                      let ty = Printtyp.tree_of_type_scheme exp.exp_type in
+                      Ophr_eval (outv, ty)
+                  | [] -> Ophr_signature []
+                  | _ -> Ophr_signature (item_list newenv sg'))
               else Ophr_signature []
           | Exception exn ->
               toplevel_env := oldenv;
diff --git a/toplevel/topmain.ml b/toplevel/topmain.ml
index 27b2ca2..ea70401 100644
--- a/toplevel/topmain.ml
+++ b/toplevel/topmain.ml
@@ -74,6 +74,7 @@ module Options = Main_args.Make_bytetop_options (struct
   let _nopromptcont = set nopromptcont
   let _nostdlib = set no_std_include
   let _principal = set principal
+  let _real_paths = set real_paths
   let _rectypes = set recursive_types
   let _stdin () = file_argument ""
   let _strict_sequence = set strict_sequence
diff --git a/typing/ctype.ml b/typing/ctype.ml
index e64d9d8..c577d52 100644
--- a/typing/ctype.ml
+++ b/typing/ctype.ml
@@ -3061,11 +3061,11 @@ let eqtype rename type_pairs subst env t1 t2 =
 type class_match_failure =
     CM_Virtual_class
   | CM_Parameter_arity_mismatch of int * int
-  | CM_Type_parameter_mismatch of (type_expr * type_expr) list
-  | CM_Class_type_mismatch of class_type * class_type
-  | CM_Parameter_mismatch of (type_expr * type_expr) list
-  | CM_Val_type_mismatch of string * (type_expr * type_expr) list
-  | CM_Meth_type_mismatch of string * (type_expr * type_expr) list
+  | CM_Type_parameter_mismatch of Env.t * (type_expr * type_expr) list
+  | CM_Class_type_mismatch of Env.t * class_type * class_type
+  | CM_Parameter_mismatch of Env.t * (type_expr * type_expr) list
+  | CM_Val_type_mismatch of string * Env.t * (type_expr * type_expr) list
+  | CM_Meth_type_mismatch of string * Env.t * (type_expr * type_expr) list
   | CM_Non_mutable_value of string
   | CM_Non_concrete_value of string
   | CM_Missing_value of string
@@ -3087,7 +3087,7 @@ let rec moregen_clty trace type_pairs env cty1 cty2 =
         moregen_clty true type_pairs env cty1 cty2
     | Cty_fun (l1, ty1, cty1'), Cty_fun (l2, ty2, cty2') when l1 = l2 ->
         begin try moregen true type_pairs env ty1 ty2 with Unify trace ->
-          raise (Failure [CM_Parameter_mismatch (expand_trace env trace)])
+          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
         end;
         moregen_clty false type_pairs env cty1' cty2'
     | Cty_signature sign1, Cty_signature sign2 ->
@@ -3100,7 +3100,7 @@ let rec moregen_clty trace type_pairs env cty1 cty2 =
           (fun (lab, k1, t1, k2, t2) ->
             begin try moregen true type_pairs env t1 t2 with Unify trace ->
               raise (Failure [CM_Meth_type_mismatch
-                                 (lab, expand_trace env trace)])
+                                 (lab, env, expand_trace env trace)])
            end)
         pairs;
       Vars.iter
@@ -3108,13 +3108,13 @@ let rec moregen_clty trace type_pairs env cty1 cty2 =
            let (mut', v', ty') = Vars.find lab sign1.cty_vars in
            try moregen true type_pairs env ty' ty with Unify trace ->
              raise (Failure [CM_Val_type_mismatch
-                                (lab, expand_trace env trace)]))
+                                (lab, env, expand_trace env trace)]))
         sign2.cty_vars
   | _ ->
       raise (Failure [])
   with
     Failure error when trace || error = [] ->
-      raise (Failure (CM_Class_type_mismatch (cty1, cty2)::error))
+      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))
 
 let match_class_types ?(trace=true) env pat_sch subj_sch =
   let type_pairs = TypePairs.create 53 in
@@ -3206,7 +3206,7 @@ let match_class_types ?(trace=true) env pat_sch subj_sch =
           Failure r -> r
         end
     | error ->
-        CM_Class_type_mismatch (patt, subj)::error
+        CM_Class_type_mismatch (env, patt, subj)::error
   in
   current_level := old_level;
   res
@@ -3222,7 +3222,7 @@ let rec equal_clty trace type_pairs subst env cty1 cty2 =
         equal_clty true type_pairs subst env cty1 cty2
     | Cty_fun (l1, ty1, cty1'), Cty_fun (l2, ty2, cty2') when l1 = l2 ->
         begin try eqtype true type_pairs subst env ty1 ty2 with Unify trace ->
-          raise (Failure [CM_Parameter_mismatch (expand_trace env trace)])
+          raise (Failure [CM_Parameter_mismatch (env, expand_trace env trace)])
         end;
         equal_clty false type_pairs subst env cty1' cty2'
     | Cty_signature sign1, Cty_signature sign2 ->
@@ -3236,7 +3236,7 @@ let rec equal_clty trace type_pairs subst env cty1 cty2 =
              begin try eqtype true type_pairs subst env t1 t2 with
                Unify trace ->
                  raise (Failure [CM_Meth_type_mismatch
-                                    (lab, expand_trace env trace)])
+                                    (lab, env, expand_trace env trace)])
              end)
           pairs;
         Vars.iter
@@ -3244,15 +3244,15 @@ let rec equal_clty trace type_pairs subst env cty1 cty2 =
              let (_, _, ty') = Vars.find lab sign1.cty_vars in
              try eqtype true type_pairs subst env ty' ty with Unify trace ->
                raise (Failure [CM_Val_type_mismatch
-                                  (lab, expand_trace env trace)]))
+                                  (lab, env, expand_trace env trace)]))
           sign2.cty_vars
     | _ ->
         raise
           (Failure (if trace then []
-                    else [CM_Class_type_mismatch (cty1, cty2)]))
+                    else [CM_Class_type_mismatch (env, cty1, cty2)]))
   with
     Failure error when trace ->
-      raise (Failure (CM_Class_type_mismatch (cty1, cty2)::error))
+      raise (Failure (CM_Class_type_mismatch (env, cty1, cty2)::error))
 
 let match_class_declarations env patt_params patt_type subj_params subj_type =
   let type_pairs = TypePairs.create 53 in
@@ -3338,7 +3338,7 @@ let match_class_declarations env patt_params patt_type subj_params subj_type =
         List.iter2 (fun p s ->
           try eqtype true type_pairs subst env p s with Unify trace ->
             raise (Failure [CM_Type_parameter_mismatch
-                               (expand_trace env trace)]))
+                               (env, expand_trace env trace)]))
           patt_params subj_params;
      (* old code: equal_clty false type_pairs subst env patt_type subj_type; *)
         equal_clty false type_pairs subst env
diff --git a/typing/ctype.mli b/typing/ctype.mli
index b254881..5b78013 100644
--- a/typing/ctype.mli
+++ b/typing/ctype.mli
@@ -183,11 +183,11 @@ val matches: Env.t -> type_expr -> type_expr -> bool
 type class_match_failure =
     CM_Virtual_class
   | CM_Parameter_arity_mismatch of int * int
-  | CM_Type_parameter_mismatch of (type_expr * type_expr) list
-  | CM_Class_type_mismatch of class_type * class_type
-  | CM_Parameter_mismatch of (type_expr * type_expr) list
-  | CM_Val_type_mismatch of string * (type_expr * type_expr) list
-  | CM_Meth_type_mismatch of string * (type_expr * type_expr) list
+  | CM_Type_parameter_mismatch of Env.t * (type_expr * type_expr) list
+  | CM_Class_type_mismatch of Env.t * class_type * class_type
+  | CM_Parameter_mismatch of Env.t * (type_expr * type_expr) list
+  | CM_Val_type_mismatch of string * Env.t * (type_expr * type_expr) list
+  | CM_Meth_type_mismatch of string * Env.t * (type_expr * type_expr) list
   | CM_Non_mutable_value of string
   | CM_Non_concrete_value of string
   | CM_Missing_value of string
diff --git a/typing/env.ml b/typing/env.ml
index 69abf02..963e4f0 100644
--- a/typing/env.ml
+++ b/typing/env.ml
@@ -670,6 +670,28 @@ let lookup_cltype lid env =
   mark_type_path env desc.clty_path;
   r
 
+(* Iter on an environment (ignoring the body of functors) *)
+
+let iter_env proj1 proj2 f env =
+  Ident.iter (fun id (x,_) -> f (Pident id) x) (proj1 env);
+  let rec iter_components path path' mcomps =
+    match EnvLazy.force !components_of_module_maker' mcomps with
+      Structure_comps comps ->
+        Tbl.iter
+          (fun s (d, n) -> f (Pdot (path, s, n)) (Pdot (path', s, n), d))
+          (proj2 comps);
+        Tbl.iter
+          (fun s (c, n) ->
+            iter_components (Pdot (path, s, n)) (Pdot (path', s, n)) c)
+          comps.comp_components
+    | Functor_comps _ -> ()
+  in
+  Ident.iter
+    (fun id ((path, comps), _) -> iter_components (Pident id) path comps)
+    env.components
+
+let iter_types f = iter_env (fun env -> env.types) (fun sc -> sc.comp_types) f
+
 (* GADT instance tracking *)
 
 let add_gadt_instance_level lv env =
diff --git a/typing/env.mli b/typing/env.mli
index ac234e9..8a92525 100644
--- a/typing/env.mli
+++ b/typing/env.mli
@@ -32,6 +32,7 @@ type t
 val empty: t
 val initial: t
 val diff: t -> t -> Ident.t list
+val iter_types: (Path.t -> Path.t * type_declaration -> unit) -> t -> unit
 
 (* Lookup by paths *)
 
diff --git a/typing/ident.ml b/typing/ident.ml
index 4196bb8..78467f7 100644
--- a/typing/ident.ml
+++ b/typing/ident.ml
@@ -182,3 +182,8 @@ let rec keys_aux stack accu = function
       keys_aux (l :: stack) (k.ident :: accu) r
 
 let keys tbl = keys_aux [] [] tbl
+
+let rec iter f = function
+    Empty -> ()
+  | Node(l, k, r, _) ->
+      iter f l; f k.ident k.data; iter f r
diff --git a/typing/ident.mli b/typing/ident.mli
index f9e5754..3328200 100644
--- a/typing/ident.mli
+++ b/typing/ident.mli
@@ -57,3 +57,4 @@ val add: t -> 'a -> 'a tbl -> 'a tbl
 val find_same: t -> 'a tbl -> 'a
 val find_name: string -> 'a tbl -> 'a
 val keys: 'a tbl -> t list
+val iter: (t -> 'a -> unit) -> 'a tbl -> unit
diff --git a/typing/includeclass.ml b/typing/includeclass.ml
index 8dc3511..8946423 100644
--- a/typing/includeclass.ml
+++ b/typing/includeclass.ml
@@ -49,36 +49,35 @@ let include_err ppf =
   | CM_Parameter_arity_mismatch (ls, lp) ->
       fprintf ppf
         "The classes do not have the same number of type parameters"
-  | CM_Type_parameter_mismatch trace ->
-      fprintf ppf "@[%a@]"
-      (Printtyp.unification_error false trace
+  | CM_Type_parameter_mismatch (env, trace) ->
+      Printtyp.report_unification_error ppf ~env ~unif:false trace
         (function ppf ->
-          fprintf ppf "A type parameter has type"))
+          fprintf ppf "A type parameter has type")
         (function ppf ->
           fprintf ppf "but is expected to have type")
-  | CM_Class_type_mismatch (cty1, cty2) ->
-      fprintf ppf
-       "@[The class type@;<1 2>%a@ is not matched by the class type@;<1 2>%a@]"
-       Printtyp.class_type cty1 Printtyp.class_type cty2
-  | CM_Parameter_mismatch trace ->
-      fprintf ppf "@[%a@]"
-      (Printtyp.unification_error false trace
+  | CM_Class_type_mismatch (env, cty1, cty2) ->
+      Printtyp.wrap_printing_env env (fun () ->
+        fprintf ppf
+          "@[The class type@;<1 2>%a@ %s@;<1 2>%a@]"
+          Printtyp.class_type cty1
+          "is not matched by the class type"
+          Printtyp.class_type cty2)
+  | CM_Parameter_mismatch (env, trace) ->
+      Printtyp.report_unification_error ppf ~env ~unif:false trace
         (function ppf ->
-          fprintf ppf "A parameter has type"))
+          fprintf ppf "A parameter has type")
         (function ppf ->
           fprintf ppf "but is expected to have type")
-  | CM_Val_type_mismatch (lab, trace) ->
-      fprintf ppf "@[%a@]"
-      (Printtyp.unification_error false trace
+  | CM_Val_type_mismatch (lab, env, trace) ->
+      Printtyp.report_unification_error ppf ~env ~unif:false trace
         (function ppf ->
-          fprintf ppf "The instance variable %s@ has type" lab))
+          fprintf ppf "The instance variable %s@ has type" lab)
         (function ppf ->
           fprintf ppf "but is expected to have type")
-  | CM_Meth_type_mismatch (lab, trace) ->
-      fprintf ppf "@[%a@]"
-      (Printtyp.unification_error false trace
+  | CM_Meth_type_mismatch (lab, env, trace) ->
+      Printtyp.report_unification_error ppf ~env ~unif:false trace
         (function ppf ->
-          fprintf ppf "The method %s@ has type" lab))
+          fprintf ppf "The method %s@ has type" lab)
         (function ppf ->
           fprintf ppf "but is expected to have type")
   | CM_Non_mutable_value lab ->
diff --git a/typing/includemod.ml b/typing/includemod.ml
index 367938a..2ee7090 100644
--- a/typing/includemod.ml
+++ b/typing/includemod.ml
@@ -40,7 +40,7 @@ type symptom =
 
 type pos =
     Module of Ident.t | Modtype of Ident.t | Arg of Ident.t | Body of Ident.t
-type error = pos list * symptom
+type error = pos list * Env.t * symptom
 
 exception Error of error list
 
@@ -56,7 +56,7 @@ let value_descriptions env cxt subst id vd1 vd2 =
   try
     Includecore.value_descriptions env vd1 vd2
   with Includecore.Dont_match ->
-    raise(Error[cxt, Value_descriptions(id, vd1, vd2)])
+    raise(Error[cxt, env, Value_descriptions(id, vd1, vd2)])
 
 (* Inclusion between type declarations *)
 
@@ -64,7 +64,8 @@ let type_declarations env cxt subst id decl1 decl2 =
   Env.mark_type_used (Ident.name id) decl1;
   let decl2 = Subst.type_declaration subst decl2 in
   let err = Includecore.type_declarations env (Ident.name id) decl1 id decl2 in
-  if err <> [] then raise(Error[cxt, Type_declarations(id, decl1, decl2, err)])
+  if err <> [] then
+    raise(Error[cxt, env, Type_declarations(id, decl1, decl2, err)])
 
 (* Inclusion between exception declarations *)
 
@@ -73,7 +74,7 @@ let exception_declarations env cxt subst id decl1 decl2 =
   let decl2 = Subst.exception_declaration subst decl2 in
   if Includecore.exception_declarations env decl1 decl2
   then ()
-  else raise(Error[cxt, Exception_declarations(id, decl1, decl2)])
+  else raise(Error[cxt, env, Exception_declarations(id, decl1, decl2)])
 
 (* Inclusion between class declarations *)
 
@@ -82,13 +83,14 @@ let class_type_declarations env cxt subst id decl1 decl2 =
   match Includeclass.class_type_declarations env decl1 decl2 with
     []     -> ()
   | reason ->
-      raise(Error[cxt, Class_type_declarations(id, decl1, decl2, reason)])
+      raise(Error[cxt, env, Class_type_declarations(id, decl1, decl2, reason)])
 
 let class_declarations env cxt subst id decl1 decl2 =
   let decl2 = Subst.class_declaration subst decl2 in
   match Includeclass.class_declarations env decl1 decl2 with
     []     -> ()
-  | reason -> raise(Error[cxt, Class_declarations(id, decl1, decl2, reason)])
+  | reason ->
+      raise(Error[cxt, env, Class_declarations(id, decl1, decl2, reason)])
 
 (* Expand a module type identifier when possible *)
 
@@ -98,7 +100,7 @@ let expand_module_path env cxt path =
   try
     Env.find_modtype_expansion path env
   with Not_found ->
-    raise(Error[cxt, Unbound_modtype_path path])
+    raise(Error[cxt, env, Unbound_modtype_path path])
 
 (* Extract name, kind and ident from a signature item *)
 
@@ -141,9 +143,9 @@ let rec modtypes env cxt subst mty1 mty2 =
     try_modtypes env cxt subst mty1 mty2
   with
     Dont_match ->
-      raise(Error[cxt, Module_types(mty1, Subst.modtype subst mty2)])
+      raise(Error[cxt, env, Module_types(mty1, Subst.modtype subst mty2)])
   | Error reasons ->
-      raise(Error((cxt, Module_types(mty1, Subst.modtype subst mty2))
+      raise(Error((cxt, env, Module_types(mty1, Subst.modtype subst mty2))
                   :: reasons))
 
 and try_modtypes env cxt subst mty1 mty2 =
@@ -243,7 +245,8 @@ and signatures env cxt subst sig1 sig2 =
             ((item1, item2, pos1) :: paired) unpaired rem
         with Not_found ->
           let unpaired =
-            if report then (cxt, Missing_field id2) :: unpaired else unpaired in
+            if report then (cxt, env, Missing_field id2) :: unpaired
+            else unpaired in
           pair_components subst paired unpaired rem
         end in
   (* Do the pairing and checking, and return the final coercion *)
@@ -298,7 +301,7 @@ and modtype_infos env cxt subst id info1 info2 =
     | (Modtype_abstract, Modtype_manifest mty2) ->
         check_modtype_equiv env cxt' (Mty_ident(Pident id)) mty2
   with Error reasons ->
-    raise(Error((cxt, Modtype_infos(id, info1, info2)) :: reasons))
+    raise(Error((cxt, env, Modtype_infos(id, info1, info2)) :: reasons))
 
 and check_modtype_equiv env cxt mty1 mty2 =
   match
@@ -306,7 +309,7 @@ and check_modtype_equiv env cxt mty1 mty2 =
      modtypes env cxt Subst.identity mty2 mty1)
   with
     (Tcoerce_none, Tcoerce_none) -> ()
-  | (_, _) -> raise(Error [cxt, Modtype_permutation])
+  | (_, _) -> raise(Error [cxt, env, Modtype_permutation])
 
 (* Simplified inclusion check between module types (for Env) *)
 
@@ -326,7 +329,8 @@ let compunit impl_name impl_sig intf_name intf_sig =
   try
     signatures Env.initial [] Subst.identity impl_sig intf_sig
   with Error reasons ->
-    raise(Error(([], Interface_mismatch(impl_name, intf_name)) :: reasons))
+    raise(Error(([], Env.empty,Interface_mismatch(impl_name, intf_name))
+                :: reasons))
 
 (* Hide the context and substitution parameters to the outside world *)
 
@@ -446,8 +450,9 @@ let context ppf cxt =
   else
     fprintf ppf "@[<hv 2>At position@ %a@]@ " context cxt
 
-let include_err ppf (cxt, err) =
-  fprintf ppf "@[<v>%a%a@]" context (List.rev cxt) include_err err
+let include_err ppf (cxt, env, err) =
+  Printtyp.wrap_printing_env env (fun () ->
+    fprintf ppf "@[<v>%a%a@]" context (List.rev cxt) include_err err)
 
 let buffer = ref ""
 let is_big obj =
@@ -463,8 +468,8 @@ let report_error ppf errs =
   if errs = [] then () else
   let (errs , err) = split_last errs in
   let pe = ref true in
-  let include_err' ppf err =
-    if not (is_big err) then fprintf ppf "%a@ " include_err err
+  let include_err' ppf (_,_,obj as err) =
+    if not (is_big obj) then fprintf ppf "%a@ " include_err err
     else if !pe then (fprintf ppf "...@ "; pe := false)
   in
   let print_errs ppf = List.iter (include_err' ppf) in
diff --git a/typing/includemod.mli b/typing/includemod.mli
index c060a58..355679c 100644
--- a/typing/includemod.mli
+++ b/typing/includemod.mli
@@ -45,7 +45,7 @@ type symptom =
 
 type pos =
     Module of Ident.t | Modtype of Ident.t | Arg of Ident.t | Body of Ident.t
-type error = pos list * symptom
+type error = pos list * Env.t * symptom
 
 exception Error of error list
 
diff --git a/typing/printtyp.ml b/typing/printtyp.ml
index 9ccbc87..3fd5221 100644
--- a/typing/printtyp.ml
+++ b/typing/printtyp.ml
@@ -189,6 +189,76 @@ let raw_type_expr ppf t =
 
 let () = Btype.print_raw := raw_type_expr
 
+(* Normalize paths *)
+
+let printing_env = ref Env.empty
+let printing_map = ref (Lazy.lazy_from_val Tbl.empty)
+
+let same_type t t' = repr t == repr t'
+
+let rec normalize_type_path env p =
+  try
+    let desc = Env.find_type p env in
+    if desc.type_private = Private then p else
+    match desc.type_manifest with
+      Some ty ->
+        begin match repr ty with
+          {desc = Tconstr (p1, tyl, _)} ->
+            if List.length desc.type_params = List.length tyl
+            && List.for_all2 same_type desc.type_params tyl
+            then normalize_type_path env p1
+            else p
+        | _ -> p
+        end
+    | None -> p
+  with
+    Not_found -> p
+
+let rec path_size = function
+    Pident id ->
+      (let s = Ident.name id in if s <> "" && s.[0] = '_' then 10 else 1),
+      -Ident.binding_time id
+  | Pdot (p, _, _) ->
+      let (l, b) = path_size p in (1+l, b)
+  | Papply (p1, p2) ->
+      let (l, b) = path_size p1 in
+      (l + fst (path_size p2), b)
+
+let set_printing_env env =
+  if not !Clflags.real_paths && env != !printing_env then begin
+    (* printf "Reset printing_map@."; *)
+    printing_env := env;
+    printing_map := lazy begin
+      (* printf "Recompute printing_map.@."; *)
+      let map = ref Tbl.empty in
+      Env.iter_types
+        (fun p (p', decl) ->
+          let p1 = normalize_type_path env p' in
+          try
+            let p2 = Tbl.find p1 !map in
+            if path_size p < path_size p2 then raise Not_found
+          with Not_found ->
+            (* printf "%a --> %a@." path p1 path p; *)
+            map := Tbl.add p1 p !map)
+        env;
+      !map
+    end
+  end
+
+let wrap_printing_env env f =
+  if env == !printing_env then f () else
+  begin
+    set_printing_env env;
+    try_finally f (fun () -> set_printing_env Env.empty)
+  end
+
+let best_type_path p =
+  if !Clflags.real_paths || !printing_env == Env.empty
+  then p
+  else try
+    Tbl.find (normalize_type_path !printing_env p) (Lazy.force !printing_map)
+  with Not_found -> p
+
 (* Print a type expression *)
 
 let names = ref ([] : (type_expr * string) list)
@@ -384,7 +454,8 @@ let rec tree_of_typexp sch ty =
     | Ttuple tyl ->
         Otyp_tuple (tree_of_typlist sch tyl)
     | Tconstr(p, tyl, abbrev) ->
-        Otyp_constr (tree_of_path p, tree_of_typlist sch tyl)
+        let p' = best_type_path p in
+        Otyp_constr (tree_of_path p', tree_of_typlist sch tyl)
     | Tvariant row ->
         let row = row_repr row in
         let fields =
@@ -402,7 +473,8 @@ let rec tree_of_typexp sch ty =
         let all_present = List.length present = List.length fields in
         begin match row.row_name with
         | Some(p, tyl) when namable_row row ->
-            let id = tree_of_path p in
+            let p' = best_type_path p in
+            let id = tree_of_path p' in
             let args = tree_of_typlist sch tyl in
             if row.row_closed && all_present then
               Otyp_constr (id, args)
@@ -410,7 +482,7 @@ let rec tree_of_typexp sch ty =
               let non_gen = is_non_gen sch px in
               let tags =
                 if all_present then None else Some (List.map fst present) in
-              Otyp_variant (non_gen, Ovar_name(tree_of_path p, args),
+              Otyp_variant (non_gen, Ovar_name(id, args),
                             row.row_closed, tags)
         | _ ->
             let non_gen =
@@ -492,7 +564,8 @@ and tree_of_typobject sch fi nm =
   | Some (p, ty :: tyl) ->
       let non_gen = is_non_gen sch (repr ty) in
       let args = tree_of_typlist sch tyl in
-      Otyp_class (non_gen, tree_of_path p, args)
+      let p' = best_type_path p in
+      Otyp_class (non_gen, tree_of_path p', args)
   | _ ->
       fatal_error "Printtyp.tree_of_typobject"
   end
@@ -868,6 +941,22 @@ let cltype_declaration id ppf cl =
 
 (* Print a module type *)
 
+let wrap_env fenv ftree arg =
+  let env = !printing_env in
+  set_printing_env (fenv env);
+  let tree = ftree arg in
+  set_printing_env env;
+  tree
+
+let rec filter_rem_sig item rem =
+  match item, rem with
+  | Sig_class _, ctydecl :: tydecl1 :: tydecl2 :: rem ->
+      ([ctydecl; tydecl1; tydecl2], rem)
+  | Sig_class_type _, tydecl1 :: tydecl2 :: rem ->
+      ([tydecl1; tydecl2], rem)
+  | _ ->
+      ([], rem)
+
 let rec tree_of_modtype = function
   | Mty_ident p ->
       Omty_ident (tree_of_path p)
@@ -875,30 +964,37 @@ let rec tree_of_modtype = function
       Omty_signature (tree_of_signature sg)
   | Mty_functor(param, ty_arg, ty_res) ->
       Omty_functor
-        (Ident.name param, tree_of_modtype ty_arg, tree_of_modtype ty_res)
-
-and tree_of_signature = function
-  | [] -> []
-  | Sig_value(id, decl) :: rem ->
-      tree_of_value_description id decl :: tree_of_signature rem
-  | Sig_type(id, _, _) :: rem when is_row_name (Ident.name id) ->
-      tree_of_signature rem
-  | Sig_type(id, decl, rs) :: rem ->
-      Osig_type(tree_of_type_decl id decl, tree_of_rec rs) ::
-      tree_of_signature rem
-  | Sig_exception(id, decl) :: rem ->
-      tree_of_exception_declaration id decl :: tree_of_signature rem
-  | Sig_module(id, mty, rs) :: rem ->
-      Osig_module (Ident.name id, tree_of_modtype mty, tree_of_rec rs) ::
-      tree_of_signature rem
-  | Sig_modtype(id, decl) :: rem ->
-      tree_of_modtype_declaration id decl :: tree_of_signature rem
-  | Sig_class(id, decl, rs) :: ctydecl :: tydecl1 :: tydecl2 :: rem ->
-      tree_of_class_declaration id decl rs :: tree_of_signature rem
-  | Sig_class_type(id, decl, rs) :: tydecl1 :: tydecl2 :: rem ->
-      tree_of_cltype_declaration id decl rs :: tree_of_signature rem
-  | _ ->
-      assert false
+        (Ident.name param, tree_of_modtype ty_arg,
+         wrap_env (Env.add_module param ty_arg) tree_of_modtype ty_res)
+
+and tree_of_signature sg =
+  wrap_env (fun env -> env) tree_of_signature_rec sg
+
+and tree_of_signature_rec = function
+    [] -> []
+  | item :: rem ->
+      let (sg, rem) = filter_rem_sig item rem in
+      let trees =
+        match item with
+        | Sig_value(id, decl) ->
+            [tree_of_value_description id decl]
+        | Sig_type(id, _, _) when is_row_name (Ident.name id) ->
+            []
+        | Sig_type(id, decl, rs) ->
+            [Osig_type(tree_of_type_decl id decl, tree_of_rec rs)]
+        | Sig_exception(id, decl) ->
+            [tree_of_exception_declaration id decl]
+        | Sig_module(id, mty, rs) ->
+            [Osig_module (Ident.name id, tree_of_modtype mty, tree_of_rec rs)]
+        | Sig_modtype(id, decl) ->
+            [tree_of_modtype_declaration id decl]
+        | Sig_class(id, decl, rs) ->
+            [tree_of_class_declaration id decl rs]
+        | Sig_class_type(id, decl, rs) ->
+            [tree_of_cltype_declaration id decl rs]
+      in
+      set_printing_env (Env.add_signature (item :: sg) !printing_env);
+      trees @ tree_of_signature_rec rem
 
 and tree_of_modtype_declaration id decl =
   let mty =
@@ -925,8 +1021,19 @@ let signature ppf sg =
 
 (* Print an unification error *)
 
+let same_path t t' =
+  let t = repr t and t' = repr t' in
+  t == t' ||
+  match t.desc, t'.desc with
+    Tconstr(p,tl,_), Tconstr(p',tl',_) ->
+      Path.same (best_type_path p) (best_type_path p') &&
+      List.length tl = List.length tl' &&
+      List.for_all2 same_type tl tl'
+  | _ ->
+      false
+
 let type_expansion t ppf t' =
-  if t == t' then type_expr ppf t else
+  if same_path t t' then type_expr ppf t else
   let t' = if proxy t == proxy t' then unalias t' else t' in
   fprintf ppf "@[<2>%a@ =@ %a@]" type_expr t type_expr t'
 
@@ -943,7 +1050,7 @@ let rec filter_trace = function
       []
   | (t1, t1') :: (t2, t2') :: rem ->
       let rem' = filter_trace rem in
-      if t1 == t1' && t2 == t2'
+      if same_path t1 t1' && same_path t2 t2'
       then rem'
       else (t1, t1') :: (t2, t2') :: rem'
   | _ -> []
@@ -959,7 +1066,8 @@ let hide_variant_name t =
 
 let prepare_expansion (t, t') =
   let t' = hide_variant_name t' in
-  mark_loops t; if t != t' then mark_loops t';
+  mark_loops t;
+  if not (same_path t t') then mark_loops t';
   (t, t')
 
 let may_prepare_expansion compact (t, t') =
@@ -1070,7 +1178,8 @@ let rec path_same_name p1 p2 =
 
 let type_same_name t1 t2 =
   match (repr t1).desc, (repr t2).desc with
-    Tconstr (p1, _, _), Tconstr (p2, _, _) -> path_same_name p1 p2
+    Tconstr (p1, _, _), Tconstr (p2, _, _) ->
+      path_same_name (best_type_path p1) (best_type_path p2)
   | _ -> ()
 
 let rec trace_same_names = function
@@ -1107,8 +1216,10 @@ let unification_error unif tr txt1 ppf txt2 =
       print_labels := true;
       raise exn
 
-let report_unification_error ppf tr txt1 txt2 =
-  unification_error true tr txt1 ppf txt2;;
+let report_unification_error ppf ?(env = !printing_env) ?(unif=true)
+    tr txt1 txt2 =
+  wrap_printing_env env (fun () -> unification_error unif tr txt1 ppf txt2)
+;;
 
 let trace fst txt ppf tr =
   print_labels := not !Clflags.classic;
@@ -1123,12 +1234,13 @@ let trace fst txt ppf tr =
     print_labels := true;
     raise exn
 
-let report_subtyping_error ppf tr1 txt1 tr2 =
-  reset ();
-  let tr1 = List.map prepare_expansion tr1
-  and tr2 = List.map prepare_expansion tr2 in
-  trace true txt1 ppf tr1;
-  if tr2 = [] then () else
-  let mis = mismatch true tr2 in
-  trace false "is not compatible with type" ppf tr2;
-  explanation true mis ppf
+let report_subtyping_error ppf ?(env = !printing_env) tr1 txt1 tr2 =
+  wrap_printing_env env (fun () -> 
+    reset ();
+    let tr1 = List.map prepare_expansion tr1
+    and tr2 = List.map prepare_expansion tr2 in
+    trace true txt1 ppf tr1;
+    if tr2 = [] then () else
+    let mis = mismatch true tr2 in
+    trace false "is not compatible with type" ppf tr2;
+    explanation true mis ppf)
diff --git a/typing/printtyp.mli b/typing/printtyp.mli
index b546670..7b58b9b 100644
--- a/typing/printtyp.mli
+++ b/typing/printtyp.mli
@@ -23,6 +23,11 @@ val ident: formatter -> Ident.t -> unit
 val tree_of_path: Path.t -> out_ident
 val path: formatter -> Path.t -> unit
 val raw_type_expr: formatter -> type_expr -> unit
+
+val wrap_printing_env: Env.t -> (unit -> 'a) -> 'a
+    (* Call the function using the environment for type path shortening *)
+    (* This affects all the printing functions below *)
+
 val reset: unit -> unit
 val mark_loops: type_expr -> unit
 val reset_and_mark_loops: type_expr -> unit
@@ -63,14 +68,10 @@ val cltype_declaration: Ident.t -> formatter -> class_type_declaration -> unit
 val type_expansion: type_expr -> Format.formatter -> type_expr -> unit
 val prepare_expansion: type_expr * type_expr -> type_expr * type_expr
 val trace: bool -> string -> formatter -> (type_expr * type_expr) list -> unit
-val unification_error:
-    bool -> (type_expr * type_expr) list ->
-    (formatter -> unit) -> formatter -> (formatter -> unit) ->
-    unit
 val report_unification_error:
-    formatter -> (type_expr * type_expr) list ->
+    formatter -> ?env:Env.t -> ?unif:bool -> (type_expr * type_expr) list ->
     (formatter -> unit) -> (formatter -> unit) ->
     unit
 val report_subtyping_error:
-    formatter -> (type_expr * type_expr) list ->
+    formatter -> ?env:Env.t -> (type_expr * type_expr) list ->
     string -> (type_expr * type_expr) list -> unit
diff --git a/typing/stypes.ml b/typing/stypes.ml
index 158062f..0e67340 100644
--- a/typing/stypes.ml
+++ b/typing/stypes.ml
@@ -127,13 +127,13 @@ let print_ident_annot pp str k =
 let print_info pp prev_loc ti =
   match ti with
   | Ti_class _ | Ti_mod _ -> prev_loc
-  | Ti_pat  {pat_loc = loc; pat_type = typ}
-  | Ti_expr {exp_loc = loc; exp_type = typ} ->
+  | Ti_pat  {pat_loc = loc; pat_type = typ; pat_env = env}
+  | Ti_expr {exp_loc = loc; exp_type = typ; exp_env = env} ->
       if loc <> prev_loc then fprintf pp "%a@." print_location loc;
       fprintf pp "type(@.  ";
       printtyp_reset_maybe loc;
       Printtyp.mark_loops typ;
-      Printtyp.type_sch pp typ;
+      Printtyp.wrap_printing_env env (fun () -> Printtyp.type_sch pp typ);
       fprintf pp "@.)@.";
       loc
   | An_call (loc, k) ->
diff --git a/typing/typeclass.ml b/typing/typeclass.ml
index 217c069..a9775ee 100644
--- a/typing/typeclass.ml
+++ b/typing/typeclass.ml
@@ -49,6 +49,8 @@ type error =
   | Mutability_mismatch of string * mutable_flag
   | No_overriding of string * string
 
+exception Error of Location.t * Env.t * error
+
 open Typedtree
 
 let ctyp desc typ env loc =
@@ -59,8 +61,6 @@ let mkcf desc loc = { cf_desc = desc; cf_loc = loc }
 let mkctf desc loc = { ctf_desc = desc; ctf_loc = loc }
 
 
-exception Error of Location.t * error
-
 
                        (**********************)
                        (*  Useful constants  *)
@@ -219,13 +219,15 @@ let enter_val cl_num vars inh lab mut virt ty val_env met_env par_env loc =
   let (id, virt) =
     try
       let (id, mut', virt', ty') = Vars.find lab !vars in
-      if mut' <> mut then raise (Error(loc, Mutability_mismatch(lab, mut)));
+      if mut' <> mut then
+        raise (Error(loc, val_env, Mutability_mismatch(lab, mut)));
       Ctype.unify val_env (instance ty) (instance ty');
       (if not inh then Some id else None),
       (if virt' = Concrete then virt' else virt)
     with
       Ctype.Unify tr ->
-        raise (Error(loc, Field_type_mismatch("instance variable", lab, tr)))
+        raise (Error(loc, val_env,
+                     Field_type_mismatch("instance variable", lab, tr)))
     | Not_found -> None, virt
   in
   let (id, _, _, _) as result =
@@ -252,7 +254,7 @@ let inheritance self_type env ovf concr_meths warn_vals loc parent =
       with Ctype.Unify trace ->
         match trace with
           _::_::_::({desc = Tfield(n, _, _, _)}, _)::rem ->
-            raise(Error(loc, Field_type_mismatch ("method", n, rem)))
+            raise(Error(loc, env, Field_type_mismatch ("method", n, rem)))
         | _ ->
             assert false
       end;
@@ -277,7 +279,7 @@ let inheritance self_type env ovf concr_meths warn_vals loc parent =
                  (cname :: Concr.elements over_vals));
       | Some Override
         when Concr.is_empty over_meths && Concr.is_empty over_vals ->
-        raise (Error(loc, No_overriding ("","")))
+        raise (Error(loc, env, No_overriding ("","")))
       | _ -> ()
       end;
 
@@ -287,7 +289,7 @@ let inheritance self_type env ovf concr_meths warn_vals loc parent =
       (cl_sig, concr_meths, warn_vals)
 
   | _ ->
-      raise(Error(loc, Structure_expected parent))
+      raise(Error(loc, env, Structure_expected parent))
 
 let virtual_method val_env meths self_type lab priv sty loc =
   let (_, ty') =
@@ -297,7 +299,7 @@ let virtual_method val_env meths self_type lab priv sty loc =
   let ty = cty.ctyp_type in
   begin
     try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
-        raise(Error(loc, Field_type_mismatch ("method", lab, trace)));
+        raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)));
   end;
   cty
 
@@ -309,7 +311,7 @@ let declare_method val_env meths self_type lab priv sty loc =
   in
   let unif ty =
     try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
-      raise(Error(loc, Field_type_mismatch ("method", lab, trace)))
+      raise(Error(loc, val_env, Field_type_mismatch ("method", lab, trace)))
   in
   match sty.ptyp_desc, priv with
     Ptyp_poly ([],sty'), Public ->
@@ -339,7 +341,7 @@ let type_constraint val_env sty sty' loc =
   let ty' = cty'.ctyp_type in
   begin
     try Ctype.unify val_env ty ty' with Ctype.Unify trace ->
-        raise(Error(loc, Unconsistent_constraint trace));
+        raise(Error(loc, val_env, Unconsistent_constraint trace));
   end;
   (cty, cty')
 
@@ -423,7 +425,7 @@ and class_signature env sty sign loc =
   begin try
     Ctype.unify env self_type dummy_obj
   with Ctype.Unify _ ->
-    raise(Error(sty.ptyp_loc, Pattern_type_clash self_type))
+    raise(Error(sty.ptyp_loc, env, Pattern_type_clash self_type))
   end;
 
   (* Class type fields *)
@@ -449,12 +451,12 @@ and class_type env scty =
     Pcty_constr (lid, styl) ->
       let (path, decl) = Typetexp.find_class_type env scty.pcty_loc lid.txt in
       if Path.same decl.clty_path unbound_class then
-        raise(Error(scty.pcty_loc, Unbound_class_type_2 lid.txt));
+        raise(Error(scty.pcty_loc, env, Unbound_class_type_2 lid.txt));
       let (params, clty) =
         Ctype.instance_class decl.clty_params decl.clty_type
       in
       if List.length params <> List.length styl then
-        raise(Error(scty.pcty_loc,
+        raise(Error(scty.pcty_loc, env,
                     Parameter_arity_mismatch (lid.txt, List.length params,
                                                    List.length styl)));
       let ctys = List.map2
@@ -463,7 +465,7 @@ and class_type env scty =
           let ty' = cty'.ctyp_type in
           begin
            try Ctype.unify env ty' ty with Ctype.Unify trace ->
-                  raise(Error(sty.ptyp_loc, Parameter_mismatch trace))
+                  raise(Error(sty.ptyp_loc, env, Parameter_mismatch trace))
             end;
             cty'
         )       styl params
@@ -569,12 +571,13 @@ let rec class_field self_loc cl_num self_type meths vars
             (Warnings.Instance_variable_override[lab.txt])
       end else begin
         if ovf = Override then
-          raise(Error(loc, No_overriding ("instance variable", lab.txt)))
+          raise(Error(loc, val_env,
+                      No_overriding ("instance variable", lab.txt)))
       end;
       if !Clflags.principal then Ctype.begin_def ();
       let exp =
         try type_exp val_env sexp with Ctype.Unify [(ty, _)] ->
-          raise(Error(loc, Make_nongen_seltype ty))
+          raise(Error(loc, val_env, Make_nongen_seltype ty))
       in
       if !Clflags.principal then begin
         Ctype.end_def ();
@@ -603,7 +606,7 @@ let rec class_field self_loc cl_num self_type meths vars
           Location.prerr_warning loc (Warnings.Method_override [lab.txt])
       end else begin
         if ovf = Override then
-          raise(Error(loc, No_overriding("method", lab.txt)))
+          raise(Error(loc, val_env, No_overriding("method", lab.txt)))
       end;
       let (_, ty) =
         Ctype.filter_self_method val_env lab.txt priv meths self_type
@@ -629,7 +632,8 @@ let rec class_field self_loc cl_num self_type meths vars
           end
       | _ -> assert false
       with Ctype.Unify trace ->
-        raise(Error(loc, Field_type_mismatch ("method", lab.txt, trace)))
+        raise(Error(loc, val_env,
+                    Field_type_mismatch ("method", lab.txt, trace)))
       end;
       let meth_expr = make_method self_loc cl_num expr in
       (* backup variables for Pexp_override *)
@@ -703,7 +707,7 @@ and class_structure cl_num final val_env met_env loc
     else self_type in
   begin try Ctype.unify val_env public_self ty with
     Ctype.Unify _ ->
-      raise(Error(spat.ppat_loc, Pattern_type_clash public_self))
+      raise(Error(spat.ppat_loc, val_env, Pattern_type_clash public_self))
   end;
   let get_methods ty =
     (fst (Ctype.flatten_fields
@@ -746,7 +750,7 @@ and class_structure cl_num final val_env met_env loc
         (fun name (mut, vr, ty) l -> if vr = Virtual then name :: l else l)
         sign.cty_vars [] in
     if mets <> [] || vals <> [] then
-      raise(Error(loc, Virtual_class(true, mets, vals)));
+      raise(Error(loc, val_env, Virtual_class(true, mets, vals)));
     let self_methods =
       List.fold_right
         (fun (lab,kind,ty) rem ->
@@ -762,7 +766,7 @@ and class_structure cl_num final val_env met_env loc
       Ctype.unify val_env private_self
         (Ctype.newty (Tobject(self_methods, ref None)));
       Ctype.unify val_env public_self self_type
-    with Ctype.Unify trace -> raise(Error(loc, Final_self_clash trace))
+    with Ctype.Unify trace -> raise(Error(loc, val_env, Final_self_clash trace))
     end;
   end;
 
@@ -797,7 +801,7 @@ and class_expr cl_num val_env met_env scl =
     Pcl_constr (lid, styl) ->
       let (path, decl) = Typetexp.find_class val_env scl.pcl_loc lid.txt in
       if Path.same decl.cty_path unbound_class then
-        raise(Error(scl.pcl_loc, Unbound_class_2 lid.txt));
+        raise(Error(scl.pcl_loc, val_env, Unbound_class_2 lid.txt));
       let tyl = List.map
           (fun sty -> transl_simple_type val_env false sty)
           styl
@@ -807,14 +811,14 @@ and class_expr cl_num val_env met_env scl =
       in
       let clty' = abbreviate_class_type path params clty in
       if List.length params <> List.length tyl then
-        raise(Error(scl.pcl_loc,
+        raise(Error(scl.pcl_loc, val_env,
                     Parameter_arity_mismatch (lid.txt, List.length params,
                                                    List.length tyl)));
       List.iter2
         (fun cty' ty ->
           let ty' = cty'.ctyp_type in
            try Ctype.unify val_env ty' ty with Ctype.Unify trace ->
-             raise(Error(cty'.ctyp_loc, Parameter_mismatch trace)))
+             raise(Error(cty'.ctyp_loc, val_env, Parameter_mismatch trace)))
         tyl params;
       let cl =
         rc {cl_desc = Tcl_ident (path, lid, tyl);
@@ -937,10 +941,11 @@ and class_expr cl_num val_env met_env scl =
               if ignore_labels && not (Btype.is_optional l) then begin
                 match sargs, more_sargs with
                   (l', sarg0)::_, _ ->
-                    raise(Error(sarg0.pexp_loc, Apply_wrong_label(l')))
+                    raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l'))
                 | _, (l', sarg0)::more_sargs ->
                     if l <> l' && l' <> "" then
-                      raise(Error(sarg0.pexp_loc, Apply_wrong_label l'))
+                      raise(Error(sarg0.pexp_loc, val_env,
+                                  Apply_wrong_label l'))
                     else ([], more_sargs,
                           Some (type_argument val_env sarg0 ty ty))
                 | _ ->
@@ -977,9 +982,9 @@ and class_expr cl_num val_env met_env scl =
             match sargs @ more_sargs with
               (l, sarg0)::_ ->
                 if omitted <> [] then
-                  raise(Error(sarg0.pexp_loc, Apply_wrong_label l))
+                  raise(Error(sarg0.pexp_loc, val_env, Apply_wrong_label l))
                 else
-                  raise(Error(cl.cl_loc, Cannot_apply cl.cl_type))
+                  raise(Error(cl.cl_loc, val_env, Cannot_apply cl.cl_type))
             | [] ->
                 (List.rev args,
                  List.fold_left
@@ -1001,7 +1006,7 @@ and class_expr cl_num val_env met_env scl =
         try
           Typecore.type_let val_env rec_flag sdefs None
         with Ctype.Unify [(ty, _)] ->
-          raise(Error(scl.pcl_loc, Make_nongen_seltype ty))
+          raise(Error(scl.pcl_loc, val_env, Make_nongen_seltype ty))
       in
       let (vals, met_env) =
         List.fold_right
@@ -1057,7 +1062,7 @@ and class_expr cl_num val_env met_env scl =
         Includeclass.class_types val_env cl.cl_type clty.cltyp_type
       with
         []    -> ()
-      | error -> raise(Error(cl.cl_loc, Class_match_failure error))
+      | error -> raise(Error(cl.cl_loc, val_env, Class_match_failure error))
       end;
       let (vals, meths, concrs) = extract_constraints clty.cltyp_type in
       rc {cl_desc = Tcl_constraint (cl, Some clty, vals, meths, concrs);
@@ -1177,7 +1182,7 @@ let class_infos define_class kind
       let params, loc = cl.pci_params in
       List.map (fun x -> enter_type_variable true loc x.txt) params
     with Already_bound ->
-      raise(Error(snd cl.pci_params, Repeated_parameter))
+      raise(Error(snd cl.pci_params, env, Repeated_parameter))
   in
 
   (* Allow self coercions (only for class declarations) *)
@@ -1215,7 +1220,7 @@ let class_infos define_class kind
     begin try
       List.iter2 (Ctype.unify env) obj_params obj_params'
     with Ctype.Unify _ ->
-      raise(Error(cl.pci_loc,
+      raise(Error(cl.pci_loc, env,
             Bad_parameters (obj_id, constr,
                             Ctype.newconstr (Path.Pident obj_id)
                                             obj_params')))
@@ -1223,7 +1228,7 @@ let class_infos define_class kind
     begin try
       Ctype.unify env ty constr
     with Ctype.Unify _ ->
-      raise(Error(cl.pci_loc,
+      raise(Error(cl.pci_loc, env,
         Abbrev_type_clash (constr, ty, Ctype.expand_head env constr)))
     end
   end;
@@ -1237,7 +1242,7 @@ let class_infos define_class kind
     begin try
       List.iter2 (Ctype.unify env) cl_params cl_params'
     with Ctype.Unify _ ->
-      raise(Error(cl.pci_loc,
+      raise(Error(cl.pci_loc, env,
             Bad_parameters (cl_id,
                             Ctype.newconstr (Path.Pident cl_id)
                                             cl_params,
@@ -1248,7 +1253,7 @@ let class_infos define_class kind
       Ctype.unify env ty cl_ty
     with Ctype.Unify _ ->
       let constr = Ctype.newconstr (Path.Pident cl_id) params in
-      raise(Error(cl.pci_loc, Abbrev_type_clash (constr, ty, cl_ty)))
+      raise(Error(cl.pci_loc, env, Abbrev_type_clash (constr, ty, cl_ty)))
     end
   end;
 
@@ -1258,7 +1263,7 @@ let class_infos define_class kind
       (constructor_type constr obj_type)
       (Ctype.instance env constr_type)
   with Ctype.Unify trace ->
-    raise(Error(cl.pci_loc,
+    raise(Error(cl.pci_loc, env,
                 Constructor_type_mismatch (cl.pci_name.txt, trace)))
   end;
 
@@ -1291,7 +1296,7 @@ let class_infos define_class kind
         (fun name (mut, vr, ty) l -> if vr = Virtual then name :: l else l)
         sign.cty_vars [] in
     if mets <> []  || vals <> [] then
-      raise(Error(cl.pci_loc, Virtual_class(true, mets, vals)));
+      raise(Error(cl.pci_loc, env, Virtual_class(true, mets, vals)));
   end;
 
   (* Misc. *)
@@ -1353,7 +1358,7 @@ let final_decl env define_class
 
   begin try Ctype.collapse_conj_params env clty.cty_params
   with Ctype.Unify trace ->
-    raise(Error(cl.pci_loc, Non_collapsable_conjunction (id, clty, trace)))
+    raise(Error(cl.pci_loc, env, Non_collapsable_conjunction (id, clty, trace)))
   end;
 
   List.iter Ctype.generalize clty.cty_params;
@@ -1374,7 +1379,7 @@ let final_decl env define_class
   end;
 
   if not (closed_class clty) then
-    raise(Error(cl.pci_loc, Non_generalizable_class (id, clty)));
+    raise(Error(cl.pci_loc, env, Non_generalizable_class (id, clty)));
 
   begin match
     Ctype.closed_class clty.cty_params
@@ -1387,7 +1392,7 @@ let final_decl env define_class
         then function ppf -> Printtyp.class_declaration id ppf clty
         else function ppf -> Printtyp.cltype_declaration id ppf cltydef
       in
-      raise(Error(cl.pci_loc, Unbound_type_var(printer, reason)))
+      raise(Error(cl.pci_loc, env, Unbound_type_var(printer, reason)))
   end;
 
   (id, cl.pci_name, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
@@ -1450,10 +1455,10 @@ let check_coercions env
       in
       begin try Ctype.subtype env cl_ty obj_ty ()
       with Ctype.Subtype (tr1, tr2) ->
-        raise(Typecore.Error(loc, Typecore.Not_subtype(tr1, tr2)))
+        raise(Typecore.Error(loc, env, Typecore.Not_subtype(tr1, tr2)))
       end;
       if not (Ctype.opened_object cl_ty) then
-        raise(Error(loc, Cannot_coerce_self obj_ty))
+        raise(Error(loc, env, Cannot_coerce_self obj_ty))
   end;
   (id, id_loc, clty, ty_id, cltydef, obj_id, obj_abbr, cl_id, cl_abbr,
    arity, pub_meths, req)
@@ -1722,3 +1727,7 @@ let report_error ppf = function
         "instance variable"
   | No_overriding (kind, name) ->
       fprintf ppf "@[The %s `%s'@ has no previous definition@]" kind name
+
+let report_error env ppf err =
+  Printtyp.wrap_printing_env env (fun () -> report_error ppf err)
+
diff --git a/typing/typeclass.mli b/typing/typeclass.mli
index 3329a82..c1a1b22 100644
--- a/typing/typeclass.mli
+++ b/typing/typeclass.mli
@@ -106,6 +106,6 @@ type error =
   | Mutability_mismatch of string * mutable_flag
   | No_overriding of string * string
 
-exception Error of Location.t * error
+exception Error of Location.t * Env.t * error
 
-val report_error : formatter -> error -> unit
+val report_error : Env.t -> formatter -> error -> unit
diff --git a/typing/typecore.ml b/typing/typecore.ml
index 84eeff5..8e17d00 100644
--- a/typing/typecore.ml
+++ b/typing/typecore.ml
@@ -62,7 +62,7 @@ type error =
   | Recursive_local_constraint of (type_expr * type_expr) list
   | Unexpected_existential
 
-exception Error of Location.t * error
+exception Error of Location.t * Env.t * error
 
 (* Forward declaration, to be filled in by Typemod.type_module *)
 
@@ -267,7 +267,7 @@ let unify_pat_types loc env ty ty' =
     unify env ty ty'
   with
     Unify trace ->
-      raise(Error(loc, Pattern_type_clash(trace)))
+      raise(Error(loc, env, Pattern_type_clash(trace)))
   | Tags(l1,l2) ->
       raise(Typetexp.Error(loc, Typetexp.Variant_tags (l1, l2)))
 
@@ -279,7 +279,7 @@ let unify_exp_types loc env ty expected_ty =
     unify env ty expected_ty
   with
     Unify trace ->
-      raise(Error(loc, Expr_type_clash(trace)))
+      raise(Error(loc, env, Expr_type_clash(trace)))
   | Tags(l1,l2) ->
       raise(Typetexp.Error(loc, Typetexp.Variant_tags (l1, l2)))
 
@@ -300,11 +300,11 @@ let unify_pat_types_gadt loc env ty ty' =
     unify_gadt ~newtype_level env ty ty'
   with
     Unify trace ->
-      raise(Error(loc, Pattern_type_clash(trace)))
+      raise(Error(loc, !env, Pattern_type_clash(trace)))
   | Tags(l1,l2) ->
       raise(Typetexp.Error(loc, Typetexp.Variant_tags (l1, l2)))
   | Unification_recursive_abbrev trace ->
-      raise(Error(loc, Recursive_local_constraint trace))
+      raise(Error(loc, !env, Recursive_local_constraint trace))
 
 
 (* Creating new conjunctive types is not allowed when typing patterns *)
@@ -371,13 +371,14 @@ let reset_pattern scope allow =
 let enter_variable ?(is_module=false) ?(is_as_variable=false) loc name ty =
   if List.exists (fun (id, _, _, _, _) -> Ident.name id = name.txt)
       !pattern_variables
-  then raise(Error(loc, Multiply_bound_variable name.txt));
+  then raise(Error(loc, Env.empty, Multiply_bound_variable name.txt));
   let id = Ident.create name.txt in
   pattern_variables :=
     (id, ty, name, loc, is_as_variable) :: !pattern_variables;
   if is_module then begin
     (* Note: unpack patterns enter a variable of the same name *)
-    if not !allow_modules then raise (Error (loc, Modules_not_allowed));
+    if not !allow_modules then
+      raise (Error (loc, Env.empty, Modules_not_allowed));
     module_variables := (name, loc) :: !module_variables
   end else
     (* moved to genannot *)
@@ -406,18 +407,18 @@ let enter_orpat_variables loc env  p1_vs p2_vs =
               unify env t1 t2
             with
             | Unify trace ->
-                raise(Error(loc, Pattern_type_clash(trace)))
+                raise(Error(loc, env, Pattern_type_clash(trace)))
             end;
           (x2,x1)::unify_vars rem1 rem2
           end
       | [],[] -> []
-      | (x,_,_,_,_)::_, [] -> raise (Error (loc, Orpat_vars x))
-      | [],(x,_,_,_,_)::_  -> raise (Error (loc, Orpat_vars x))
+      | (x,_,_,_,_)::_, [] -> raise (Error (loc, env, Orpat_vars x))
+      | [],(x,_,_,_,_)::_  -> raise (Error (loc, env, Orpat_vars x))
       | (x,_,_,_,_)::_, (y,_,_,_,_)::_ ->
           let min_var =
             if Ident.name x < Ident.name y then x
             else y in
-          raise (Error (loc, Orpat_vars min_var)) in
+          raise (Error (loc, env, Orpat_vars min_var)) in
   unify_vars p1_vs p2_vs
 
 let rec build_as_type env p =
@@ -481,7 +482,7 @@ let build_or_pat env loc lid =
     let ty = expand_head env (newty(Tconstr(path, tyl, ref Mnil))) in
     match ty.desc with
       Tvariant row when static_row row -> row
-    | _ -> raise(Error(loc, Not_a_variant_type lid))
+    | _ -> raise(Error(loc, env, Not_a_variant_type lid))
   in
   let pats, fields =
     List.fold_left
@@ -510,7 +511,7 @@ let build_or_pat env loc lid =
       pats
   in
   match pats with
-    [] -> raise(Error(loc, Not_a_variant_type lid))
+    [] -> raise(Error(loc, env, Not_a_variant_type lid))
   | pat :: pats ->
       let r =
         List.fold_left
@@ -567,7 +568,7 @@ let check_recordpat_labels loc lbl_pat_list closed =
       let defined = Array.make (Array.length all) false in
       let check_defined (_, _, label, _) =
         if defined.(label.lbl_pos)
-        then raise(Error(loc, Label_multiply_defined
+        then raise(Error(loc, Env.empty, Label_multiply_defined
                                        (Longident.Lident label.lbl_name)))
         else defined.(label.lbl_pos) <- true in
       List.iter check_defined lbl_pat_list;
@@ -692,7 +693,7 @@ let rec type_pat ~constrs ~labels ~no_existentials ~mode ~env sp expected_ty =
       in
       Env.mark_constructor Env.Pattern !env (Longident.last lid.txt) constr;
       if no_existentials && constr.cstr_existentials <> [] then
-        raise (Error (loc, Unexpected_existential));
+        raise (Error (loc, !env, Unexpected_existential));
       (* if constructor is gadt, we must verify that the expected type has the
          correct head *)
       if constr.cstr_generalized then
@@ -709,7 +710,7 @@ let rec type_pat ~constrs ~labels ~no_existentials ~mode ~env sp expected_ty =
             replicate_list sp constr.cstr_arity
         | Some sp -> [sp] in
       if List.length sargs <> constr.cstr_arity then
-        raise(Error(loc, Constructor_arity_mismatch(lid.txt,
+        raise(Error(loc, !env, Constructor_arity_mismatch(lid.txt,
                                      constr.cstr_arity, List.length sargs)));
       let (ty_args, ty_res) =
         instance_constructor ~in_pattern:(env, get_newtype_level ()) constr
@@ -748,7 +749,7 @@ let rec type_pat ~constrs ~labels ~no_existentials ~mode ~env sp expected_ty =
         begin try
           unify_pat_types loc !env ty_res expected_ty
         with Unify trace ->
-          raise(Error(loc, Label_mismatch(lid_of_label label, trace)))
+          raise(Error(loc, !env, Label_mismatch(lid_of_label label, trace)))
         end;
         let arg = type_pat sarg ty_arg in
         if vars <> [] then begin
@@ -759,7 +760,7 @@ let rec type_pat ~constrs ~labels ~no_existentials ~mode ~env sp expected_ty =
             let tv = expand_head !env tv in
             not (is_Tvar tv) || tv.level <> generic_level in
           if List.exists instantiated vars then
-            raise (Error(loc, Polymorphic_label (lid_of_label label)))
+            raise (Error(loc, !env, Polymorphic_label (lid_of_label label)))
         end;
         (label_path, label_lid, label, arg)
       in
@@ -1085,9 +1086,9 @@ let type_format loc fmt =
   let ty_arrow gty ty = newty (Tarrow ("", instance_def gty, ty, Cok)) in
 
   let bad_conversion fmt i c =
-    raise (Error (loc, Bad_conversion (fmt, i, c))) in
+    raise (Error (loc, Env.empty, Bad_conversion (fmt, i, c))) in
   let incomplete_format fmt =
-    raise (Error (loc, Incomplete_format fmt)) in
+    raise (Error (loc, Env.empty, Incomplete_format fmt)) in
 
   let rec type_in_format fmt =
 
@@ -1315,7 +1316,7 @@ let rec type_approx env sexp =
       and ty1 = approx_ty_opt sty1
       and ty2 = approx_ty_opt sty2 in
       begin try unify env ty ty1 with Unify trace ->
-        raise(Error(sexp.pexp_loc, Expr_type_clash trace))
+        raise(Error(sexp.pexp_loc, env, Expr_type_clash trace))
       end;
       if sty2 = None then ty1 else ty2
   | _ -> newvar ()
@@ -1353,7 +1354,7 @@ let check_univars env expans kind exp ty_expected vars =
   if List.length vars = List.length vars' then () else
   let ty = newgenty (Tpoly(repr exp.exp_type, vars'))
   and ty_expected = repr ty_expected in
-  raise (Error (exp.exp_loc,
+  raise (Error (exp.exp_loc, env,
                 Less_general(kind, [ty, ty; ty_expected, ty_expected])))
 
 (* Check that a type is not a function *)
@@ -1514,7 +1515,7 @@ and type_expect ?in_function env sexp ty_expected =
                 in
                 Texp_ident(path, lid, desc)
             | Val_unbound ->
-                raise(Error(loc, Masked_instance_variable lid.txt))
+                raise(Error(loc, env, Masked_instance_variable lid.txt))
             | _ ->
                 Texp_ident(path, lid, desc)
           end;
@@ -1614,9 +1615,9 @@ and type_expect ?in_function env sexp ty_expected =
         with Unify _ ->
           match expand_head env ty_expected with
             {desc = Tarrow _} as ty ->
-              raise(Error(loc, Abstract_wrong_label(l, ty)))
+              raise(Error(loc, env, Abstract_wrong_label(l, ty)))
           | _ ->
-              raise(Error(loc_fun,
+              raise(Error(loc_fun, env,
                           Too_many_arguments (in_function <> None, ty_fun)))
       in
       let ty_arg =
@@ -1756,7 +1757,7 @@ and type_expect ?in_function env sexp ty_expected =
         match (lid_sexp, lbl_exp) with
           ((lid, _) :: rem1, (_, _, lbl, _) :: rem2) ->
             if List.mem lbl.lbl_pos seen_pos
-            then raise(Error(loc, Label_multiply_defined lid.txt))
+            then raise(Error(loc, env, Label_multiply_defined lid.txt))
             else check_duplicates (lbl.lbl_pos :: seen_pos) rem1 rem2
         | (_, _) -> () in
       check_duplicates [] lid_sexp_list lbl_exp_list;
@@ -1799,7 +1800,7 @@ and type_expect ?in_function env sexp ty_expected =
               else lbl :: missing_labels (n + 1) rem
         in
         let missing = missing_labels 0 label_names in
-        raise(Error(loc, Label_missing missing))
+        raise(Error(loc, env, Label_missing missing))
       end
       else if opt_sexp <> None && List.length lid_sexp_list = num_fields then
         Location.prerr_warning loc Warnings.Useless_record_with;
@@ -1825,7 +1826,7 @@ and type_expect ?in_function env sexp ty_expected =
         type_label_exp false env loc record.exp_type
           (label_path, lid, label, snewval) in
       if label.lbl_mut = Immutable then
-        raise(Error(loc, Label_not_mutable lid.txt));
+        raise(Error(loc, env, Label_not_mutable lid.txt));
       rue {
         exp_desc = Texp_setfield(record, label_path, label_loc, label, newval);
         exp_loc = loc; exp_extra = [];
@@ -1952,13 +1953,13 @@ and type_expect ?in_function env sexp ty_expected =
                       (Warnings.Not_principal "this ground coercion");
                 with Subtype (tr1, tr2) ->
                   (* prerr_endline "coercion failed"; *)
-                  raise(Error(loc, Not_subtype(tr1, tr2)))
+                  raise(Error(loc, env, Not_subtype(tr1, tr2)))
                 end;
             | _ ->
                 let ty, b = enlarge_type env ty' in
                 force ();
                 begin try Ctype.unify env arg.exp_type ty with Unify trace ->
-                  raise(Error(sarg.pexp_loc,
+                  raise(Error(sarg.pexp_loc, env,
                         Coercion_failure(ty', full_expand env ty', trace, b)))
                 end
             end;
@@ -1976,7 +1977,7 @@ and type_expect ?in_function env sexp ty_expected =
               let force'' = subtype env ty ty' in
               force (); force' (); force'' ()
             with Subtype (tr1, tr2) ->
-              raise(Error(loc, Not_subtype(tr1, tr2)))
+              raise(Error(loc, env, Not_subtype(tr1, tr2)))
             end;
             if separate then begin
               end_def ();
@@ -2019,7 +2020,7 @@ and type_expect ?in_function env sexp ty_expected =
           | Texp_ident(path, lid, {val_kind = Val_anc (methods, cl_num)}) ->
               let method_id =
                 begin try List.assoc met methods with Not_found ->
-                  raise(Error(e.pexp_loc, Undefined_inherited_method met))
+                  raise(Error(e.pexp_loc, env, Undefined_inherited_method met))
                 end
               in
               begin match
@@ -2090,13 +2091,13 @@ and type_expect ?in_function env sexp ty_expected =
           exp_type = typ;
           exp_env = env }
       with Unify _ ->
-        raise(Error(e.pexp_loc, Undefined_method (obj.exp_type, met)))
+        raise(Error(e.pexp_loc, env, Undefined_method (obj.exp_type, met)))
       end
   | Pexp_new cl ->
       let (cl_path, cl_decl) = Typetexp.find_class env loc cl.txt in
         begin match cl_decl.cty_new with
           None ->
-            raise(Error(loc, Virtual_class cl.txt))
+            raise(Error(loc, env, Virtual_class cl.txt))
         | Some ty ->
             rue {
               exp_desc = Texp_new (cl_path, cl, cl_decl);
@@ -2120,19 +2121,19 @@ and type_expect ?in_function env sexp ty_expected =
               exp_type = instance_def Predef.type_unit;
               exp_env = env }
         | Val_ivar _ ->
-            raise(Error(loc,Instance_variable_not_mutable(true,lab.txt)))
+            raise(Error(loc, env, Instance_variable_not_mutable(true,lab.txt)))
         | _ ->
-            raise(Error(loc,Instance_variable_not_mutable(false,lab.txt)))
+            raise(Error(loc, env, Instance_variable_not_mutable(false,lab.txt)))
       with
         Not_found ->
-          raise(Error(loc, Unbound_instance_variable lab.txt))
+          raise(Error(loc, env, Unbound_instance_variable lab.txt))
       end
   | Pexp_override lst ->
       let _ =
        List.fold_right
         (fun (lab, _) l ->
            if List.exists (fun l -> l.txt = lab.txt) l then
-             raise(Error(loc,
+             raise(Error(loc, env,
                          Value_multiply_overridden lab.txt));
            lab::l)
         lst
@@ -2142,7 +2143,7 @@ and type_expect ?in_function env sexp ty_expected =
           Env.lookup_value (Longident.Lident "selfpat-*") env,
           Env.lookup_value (Longident.Lident "self-*") env
         with Not_found ->
-          raise(Error(loc, Outside_class))
+          raise(Error(loc, env, Outside_class))
       with
         (_, {val_type = self_ty; val_kind = Val_self (_, vars, _, _)}),
         (path_self, _) ->
@@ -2152,7 +2153,7 @@ and type_expect ?in_function env sexp ty_expected =
               (Path.Pident id, lab, type_expect env snewval (instance env ty))
             with
               Not_found ->
-                raise(Error(loc, Unbound_instance_variable lab.txt))
+                raise(Error(loc, env, Unbound_instance_variable lab.txt))
             end
           in
           let modifs = List.map type_override lst in
@@ -2185,7 +2186,7 @@ and type_expect ?in_function env sexp ty_expected =
       begin try
         Ctype.unify_var new_env ty body.exp_type
       with Unify _ ->
-        raise(Error(loc, Scoping_let_module(name.txt, body.exp_type)))
+        raise(Error(loc, env, Scoping_let_module(name.txt, body.exp_type)))
       end;
       re {
         exp_desc = Texp_letmodule(id, name, modl, body);
@@ -2322,9 +2323,9 @@ and type_expect ?in_function env sexp ty_expected =
                 (Warnings.Not_principal "this module packing");
             (p, nl, tl)
         | {desc = Tvar _} ->
-            raise (Error (loc, Cannot_infer_signature))
+            raise (Error (loc, env, Cannot_infer_signature))
         | _ ->
-            raise (Error (loc, Not_a_packed_module ty_expected))
+            raise (Error (loc, env, Not_a_packed_module ty_expected))
       in
       let (modl, tl') = !type_package env m p nl tl in
       rue {
@@ -2355,7 +2356,7 @@ and type_label_exp create env loc ty_expected
   begin try
     unify env (instance_def ty_res) (instance env ty_expected)
   with Unify trace ->
-    raise (Error(lid.loc, Label_mismatch(lid_of_label label, trace)))
+    raise(Error(lid.loc , env, Label_mismatch(lid_of_label label, trace)))
   end;
   (* Instantiate so that we can generalize internal nodes *)
   let ty_arg = instance_def ty_arg in
@@ -2366,9 +2367,10 @@ and type_label_exp create env loc ty_expected
   end;
   if label.lbl_private = Private then
     if create then
-      raise (Error(loc, Private_type ty_expected))
+      raise (Error(loc, env, Private_type ty_expected))
     else
-      raise (Error(lid.loc, Private_label(lid_of_label label, ty_expected)));
+      raise (Error(lid.loc, env,
+                   Private_label(lid_of_label label, ty_expected)));
   let arg =
     let snap = if vars = [] then None else Some (Btype.snapshot ()) in
     let arg = type_argument env sarg ty_arg (instance env ty_arg) in
@@ -2386,7 +2388,7 @@ and type_label_exp create env loc ty_expected
       unify_exp env arg ty_arg;
       check_univars env false "field value" arg label.lbl_arg vars;
       arg
-    with Error (_, Less_general _) as e -> raise e
+    with Error (_, _, Less_general _) as e -> raise e
     | _ -> raise exn    (* In case of failure return the first error *)
   in
   (label_path, lid, label, {arg with exp_type = instance env arg.exp_type})
@@ -2519,11 +2521,12 @@ and type_application env funct sargs =
               match ty_res.desc with
                 Tarrow _ ->
                   if (!Clflags.classic || not (has_label l1 ty_fun)) then
-                    raise(Error(sarg1.pexp_loc, Apply_wrong_label(l1, ty_res)))
+                    raise (Error(sarg1.pexp_loc, env,
+                                 Apply_wrong_label(l1, ty_res)))
                   else
-                    raise(Error(funct.exp_loc, Incoherent_label_order))
+                    raise (Error(funct.exp_loc, env, Incoherent_label_order))
               | _ ->
-                  raise(Error(funct.exp_loc, Apply_non_function
+                  raise(Error(funct.exp_loc, env, Apply_non_function
                                 (expand_head env funct.exp_type)))
         in
         let optional = if is_optional l1 then Optional else Required in
@@ -2568,10 +2571,12 @@ and type_application env funct sargs =
             (* In classic mode, omitted = [] *)
             match sargs, more_sargs with
               (l', sarg0) :: _, _ ->
-                raise(Error(sarg0.pexp_loc, Apply_wrong_label(l', ty_old)))
+                raise(Error(sarg0.pexp_loc, env,
+                            Apply_wrong_label(l', ty_old)))
             | _, (l', sarg0) :: more_sargs ->
                 if l <> l' && l' <> "" then
-                  raise(Error(sarg0.pexp_loc, Apply_wrong_label(l', ty_fun')))
+                  raise(Error(sarg0.pexp_loc, env,
+                              Apply_wrong_label(l', ty_fun')))
                 else
                   ([], more_sargs,
                    Some (fun () -> type_argument env sarg0 ty ty0))
@@ -2626,7 +2631,8 @@ and type_application env funct sargs =
     | _ ->
         match sargs with
           (l, sarg0) :: _ when ignore_labels ->
-            raise(Error(sarg0.pexp_loc, Apply_wrong_label(l, ty_old)))
+            raise(Error(sarg0.pexp_loc, env,
+                        Apply_wrong_label(l, ty_old)))
         | _ ->
             type_unknown_args args omitted ty_fun0
               (sargs @ more_sargs)
@@ -2662,7 +2668,7 @@ and type_construct env loc lid sarg explicit_arity ty_expected =
     | Some {pexp_desc = Pexp_tuple sel} when constr.cstr_arity > 1 -> sel
     | Some se -> [se] in
   if List.length sargs <> constr.cstr_arity then
-    raise(Error(loc, Constructor_arity_mismatch
+    raise(Error(loc, env, Constructor_arity_mismatch
                   (lid.txt, constr.cstr_arity, List.length sargs)));
   let separate = !Clflags.principal || Env.has_local_constraints env in
   if separate then (begin_def (); begin_def ());
@@ -2692,7 +2698,7 @@ and type_construct env loc lid sarg explicit_arity ty_expected =
   let args = List.map2 (fun e (t,t0) -> type_argument env e t t0) sargs
       (List.combine ty_args ty_args0) in
   if constr.cstr_private = Private then
-    raise(Error(loc, Private_type ty_res));
+    raise(Error(loc, env, Private_type ty_res));
   { texp with
     exp_desc = Texp_construct(path, lid, constr, args, explicit_arity) }
 
@@ -3209,5 +3215,8 @@ let report_error ppf = function
       fprintf ppf
         "Unexpected existential"
 
+let report_error env ppf err =
+  wrap_printing_env env (fun () -> report_error ppf err)
+
 let () =
   Env.add_delayed_check_forward := add_delayed_check
diff --git a/typing/typecore.mli b/typing/typecore.mli
index 92df37f..da9422c 100644
--- a/typing/typecore.mli
+++ b/typing/typecore.mli
@@ -104,9 +104,9 @@ type error =
   | Recursive_local_constraint of (type_expr * type_expr) list
   | Unexpected_existential
 
-exception Error of Location.t * error
+exception Error of Location.t * Env.t * error
 
-val report_error: formatter -> error -> unit
+val report_error: Env.t -> formatter -> error -> unit
 
 (* Forward declaration, to be filled in by Typemod.type_module *)
 val type_module: (Env.t -> Parsetree.module_expr -> Typedtree.module_expr) ref
diff --git a/typing/typedecl.ml b/typing/typedecl.ml
index 709de84..67a13c8 100644
--- a/typing/typedecl.ml
+++ b/typing/typedecl.ml
@@ -29,8 +29,8 @@ type error =
   | Recursive_abbrev of string
   | Definition_mismatch of type_expr * Includecore.type_mismatch list
   | Constraint_failed of type_expr * type_expr
-  | Inconsistent_constraint of (type_expr * type_expr) list
-  | Type_clash of (type_expr * type_expr) list
+  | Inconsistent_constraint of Env.t * (type_expr * type_expr) list
+  | Type_clash of Env.t * (type_expr * type_expr) list
   | Parameters_differ of Path.t * type_expr * type_expr
   | Null_arity_external
   | Missing_native_external
@@ -74,7 +74,7 @@ let update_type temp_env env id loc =
       let params = List.map (fun _ -> Ctype.newvar ()) decl.type_params in
       try Ctype.unify env (Ctype.newconstr path params) ty
       with Ctype.Unify trace ->
-        raise (Error(loc, Type_clash trace))
+        raise (Error(loc, Type_clash (env, trace)))
 
 (* Determine if a type is (an abbreviation for) the type "float" *)
 (* We use the Ctype.expand_head_opt version of expand_head to get access
@@ -240,7 +240,7 @@ let transl_declaration env (name, sdecl) id =
         let ty = cty.ctyp_type in
         let ty' = cty'.ctyp_type in
         try Ctype.unify env ty ty' with Ctype.Unify tr ->
-          raise(Error(loc, Inconsistent_constraint tr)))
+          raise(Error(loc, Inconsistent_constraint (env, tr))))
       cstrs;
     Ctype.end_def ();
   (* Add abstract row *)
@@ -410,7 +410,7 @@ let check_well_founded env loc path decl =
       try Ctype.correct_abbrev env path decl.type_params body with
       | Ctype.Recursive_abbrev ->
           raise(Error(loc, Recursive_abbrev (Path.name path)))
-      | Ctype.Unify trace -> raise(Error(loc, Type_clash trace)))
+      | Ctype.Unify trace -> raise(Error(loc, Type_clash (env, trace))))
     decl.type_manifest
 
 (* Check for ill-defined abbrevs *)
@@ -948,7 +948,7 @@ let transl_with_constraint env id row_path orig_decl sdecl =
          Ctype.unify env ty ty';
          (cty, cty', loc)
        with Ctype.Unify tr ->
-         raise(Error(loc, Inconsistent_constraint tr)))
+         raise(Error(loc, Inconsistent_constraint (env, tr))))
     sdecl.ptype_cstrs
   in
   let no_row = not (is_fixed_type sdecl) in
@@ -1099,13 +1099,13 @@ let report_error ppf = function
       fprintf ppf
         "@[<hv>In the definition of %s, type@ %a@ should be@ %a@]"
         (Path.name path) Printtyp.type_expr ty Printtyp.type_expr ty'
-  | Inconsistent_constraint trace ->
+  | Inconsistent_constraint (env, trace) ->
       fprintf ppf "The type constraints are not consistent.@.";
-      Printtyp.report_unification_error ppf trace
+      Printtyp.report_unification_error ppf ~env trace
         (fun ppf -> fprintf ppf "Type")
         (fun ppf -> fprintf ppf "is not compatible with type")
-  | Type_clash trace ->
-      Printtyp.report_unification_error ppf trace
+  | Type_clash (env, trace) ->
+      Printtyp.report_unification_error ppf ~env trace
         (function ppf ->
            fprintf ppf "This type constructor expands to type")
         (function ppf ->
diff --git a/typing/typedecl.mli b/typing/typedecl.mli
index d911d05..c2b62fa 100644
--- a/typing/typedecl.mli
+++ b/typing/typedecl.mli
@@ -64,8 +64,8 @@ type error =
   | Recursive_abbrev of string
   | Definition_mismatch of type_expr * Includecore.type_mismatch list
   | Constraint_failed of type_expr * type_expr
-  | Inconsistent_constraint of (type_expr * type_expr) list
-  | Type_clash of (type_expr * type_expr) list
+  | Inconsistent_constraint of Env.t * (type_expr * type_expr) list
+  | Type_clash of Env.t * (type_expr * type_expr) list
   | Parameters_differ of Path.t * type_expr * type_expr
   | Null_arity_external
   | Missing_native_external
diff --git a/typing/typemod.ml b/typing/typemod.ml
index 8812ea3..034d6ca 100644
--- a/typing/typemod.ml
+++ b/typing/typemod.ml
@@ -40,7 +40,7 @@ type error =
   | Incomplete_packed_module of type_expr
   | Scoping_pack of Longident.t * type_expr
 
-exception Error of Location.t * error
+exception Error of Location.t * Env.t * error
 
 open Typedtree
 
@@ -57,12 +57,12 @@ let rec path_concat head p =
 let extract_sig env loc mty =
   match Mtype.scrape env mty with
     Mty_signature sg -> sg
-  | _ -> raise(Error(loc, Signature_expected))
+  | _ -> raise(Error(loc, env, Signature_expected))
 
 let extract_sig_open env loc mty =
   match Mtype.scrape env mty with
     Mty_signature sg -> sg
-  | _ -> raise(Error(loc, Structure_expected mty))
+  | _ -> raise(Error(loc, env, Structure_expected mty))
 
 (* Compute the environment after opening a module *)
 
@@ -121,7 +121,7 @@ let merge_constraint initial_env loc  sg lid constr =
   let rec merge env sg namelist row_id =
     match (sg, namelist, constr) with
       ([], _, _) ->
-        raise(Error(loc, With_no_component lid.txt))
+        raise(Error(loc, env, With_no_component lid.txt))
     | (Sig_type(id, decl, rs) :: rem, [s],
        Pwith_type ({ptype_kind = Ptype_abstract} as sdecl))
       when Ident.name id = s && Typedecl.is_fixed_type sdecl ->
@@ -216,7 +216,8 @@ let merge_constraint initial_env loc  sg lid constr =
               ) params sdecl.ptype_params;
               lid
           | _ -> raise Exit
-          with Exit -> raise (Error (sdecl.ptype_loc, With_need_typeconstr))
+          with Exit ->
+            raise(Error(sdecl.ptype_loc, initial_env, With_need_typeconstr))
         in
         let (path, _) =
           try Env.lookup_type lid.txt initial_env with Not_found -> assert false
@@ -234,7 +235,7 @@ let merge_constraint initial_env loc  sg lid constr =
     in
     (tcstr, sg)
   with Includemod.Error explanation ->
-    raise(Error(loc, With_mismatch(lid.txt, explanation)))
+    raise(Error(loc, initial_env, With_mismatch(lid.txt, explanation)))
 
 (* Add recursion flags on declarations arising from a mutually recursive
    block. *)
@@ -244,11 +245,14 @@ let map_rec fn decls rem =
   | [] -> rem
   | d1 :: dl -> fn Trec_first d1 :: map_end (fn Trec_next) dl rem
 
+let map_rec' = map_rec
+(*
 let rec map_rec' fn decls rem =
   match decls with
   | (id,_ as d1) :: dl when Btype.is_row_name (Ident.name id) ->
       fn Trec_not d1 :: map_rec' fn dl rem
   | _ -> map_rec fn decls rem
+*)
 
 let rec map_rec'' fn decls rem =
   match decls with
@@ -358,7 +362,7 @@ module StringSet = Set.Make(struct type t = string let compare = compare end)
 
 let check cl loc set_ref name =
   if StringSet.mem name !set_ref
-  then raise(Error(loc, Repeated_name(cl, name)))
+  then raise(Error(loc, Env.empty, Repeated_name(cl, name)))
   else set_ref := StringSet.add name !set_ref
 
 let check_sig_item type_names module_names modtype_names loc = function
@@ -643,11 +647,11 @@ let check_nongen_scheme env str =
       List.iter
         (fun (pat, exp) ->
           if not (Ctype.closed_schema exp.exp_type) then
-            raise(Error(exp.exp_loc, Non_generalizable exp.exp_type)))
+            raise(Error(exp.exp_loc, env, Non_generalizable exp.exp_type)))
         pat_exp_list
   | Tstr_module(id, _, md) ->
       if not (closed_modtype md.mod_type) then
-        raise(Error(md.mod_loc, Non_generalizable_module md.mod_type))
+        raise(Error(md.mod_loc, env, Non_generalizable_module md.mod_type))
   | _ -> ()
 
 let check_nongen_schemes env str =
@@ -754,7 +758,7 @@ let check_recmodule_inclusion env bindings =
           try
             Includemod.modtypes env mty_actual' mty_decl'
           with Includemod.Error msg ->
-            raise(Error(modl.mod_loc, Not_included msg)) in
+            raise(Error(modl.mod_loc, env, Not_included msg)) in
         let modl' =
             { mod_desc = Tmod_constraint(modl, mty_decl.mty_type,
                 Tmodtype_explicit mty_decl, coercion);
@@ -799,7 +803,7 @@ let modtype_of_package env loc p nl tl =
         (List.combine (List.map Longident.flatten nl) tl)
   | _ ->
       if nl = [] then Mty_ident p
-      else raise(Error(loc, Signature_expected))
+      else raise(Error(loc, env, Signature_expected))
   with Not_found ->
     raise(Typetexp.Error(loc, Typetexp.Unbound_modtype (Ctype.lid_of_path p)))
 
@@ -808,7 +812,7 @@ let wrap_constraint env arg mty explicit =
     try
       Includemod.modtypes env arg.mod_type mty
     with Includemod.Error msg ->
-      raise(Error(arg.mod_loc, Not_included msg)) in
+      raise(Error(arg.mod_loc, env, Not_included msg)) in
   { mod_desc = Tmod_constraint(arg, mty, explicit, coercion);
     mod_type = mty;
     mod_env = env;
@@ -855,7 +859,7 @@ let rec type_module sttn funct_body anchor env smod =
             try
               Includemod.modtypes env arg.mod_type mty_param
             with Includemod.Error msg ->
-              raise(Error(sarg.pmod_loc, Not_included msg)) in
+              raise(Error(sarg.pmod_loc, env, Not_included msg)) in
           let mty_appl =
             match path with
               Some path ->
@@ -866,7 +870,7 @@ let rec type_module sttn funct_body anchor env smod =
                   Mtype.nondep_supertype
                     (Env.add_module param arg.mod_type env) param mty_res
                 with Not_found ->
-                  raise(Error(smod.pmod_loc,
+                  raise(Error(smod.pmod_loc, env,
                               Cannot_eliminate_dependency mty_functor))
           in
           rm { mod_desc = Tmod_apply(funct, arg, coercion);
@@ -874,7 +878,7 @@ let rec type_module sttn funct_body anchor env smod =
                mod_env = env;
                mod_loc = smod.pmod_loc }
       | _ ->
-          raise(Error(sfunct.pmod_loc, Cannot_apply funct.mod_type))
+          raise(Error(sfunct.pmod_loc, env, Cannot_apply funct.mod_type))
       end
   | Pmod_constraint(sarg, smty) ->
       let arg = type_module true funct_body anchor env sarg in
@@ -884,7 +888,7 @@ let rec type_module sttn funct_body anchor env smod =
 
   | Pmod_unpack sexp ->
       if funct_body then
-        raise (Error (smod.pmod_loc, Not_allowed_in_functor_body));
+        raise (Error (smod.pmod_loc, env, Not_allowed_in_functor_body));
       if !Clflags.principal then Ctype.begin_def ();
       let exp = Typecore.type_exp env sexp in
       if !Clflags.principal then begin
@@ -895,7 +899,7 @@ let rec type_module sttn funct_body anchor env smod =
         match Ctype.expand_head env exp.exp_type with
           {desc = Tpackage (p, nl, tl)} ->
             if List.exists (fun t -> Ctype.free_variables t <> []) tl then
-              raise (Error (smod.pmod_loc,
+              raise (Error (smod.pmod_loc, env,
                             Incomplete_packed_module exp.exp_type));
             if !Clflags.principal &&
               not (Typecore.generalizable (Btype.generic_level-1) exp.exp_type)
@@ -905,9 +909,9 @@ let rec type_module sttn funct_body anchor env smod =
             modtype_of_package env smod.pmod_loc p nl tl
         | {desc = Tvar _} ->
             raise (Typecore.Error
-                     (smod.pmod_loc, Typecore.Cannot_infer_signature))
+                     (smod.pmod_loc, env, Typecore.Cannot_infer_signature))
         | _ ->
-            raise (Error (smod.pmod_loc, Not_a_packed_module exp.exp_type))
+            raise (Error(smod.pmod_loc, env, Not_a_packed_module exp.exp_type))
       in
       rm { mod_desc = Tmod_unpack(exp, mty);
            mod_type = mty;
@@ -1178,7 +1182,7 @@ let type_module_type_of env smod =
   let mty = simplify_modtype mty in
   (* PR#5036: must not contain non-generalized type variables *)
   if not (closed_modtype mty) then
-    raise(Error(smod.pmod_loc, Non_generalizable_module mty));
+    raise(Error(smod.pmod_loc, env, Non_generalizable_module mty));
   tmty, mty
 
 (* For Typecore *)
@@ -1221,7 +1225,8 @@ let type_package env m p nl tl =
   List.iter2
     (fun n ty ->
       try Ctype.unify env ty (Ctype.newvar ())
-      with Ctype.Unify _ -> raise (Error(m.pmod_loc, Scoping_pack (n,ty))))
+      with Ctype.Unify _ ->
+        raise (Error(m.pmod_loc, env, Scoping_pack (n,ty))))
     nl tl';
   (wrap_constraint env modl mty Tmodtype_implicit, tl')
 
@@ -1243,7 +1248,8 @@ let type_implementation sourcefile outputprefix modulename initial_env ast =
   let (str, sg, finalenv) = type_structure initial_env ast Location.none in
   let simple_sg = simplify_signature sg in
   if !Clflags.print_types then begin
-    fprintf std_formatter "%a@." Printtyp.signature simple_sg;
+    Printtyp.wrap_printing_env initial_env
+      (fun () -> fprintf std_formatter "%a@." Printtyp.signature simple_sg);
     (str, Tcoerce_none)   (* result is ignored by Compile.implementation *)
   end else begin
     let sourceintf =
@@ -1253,7 +1259,8 @@ let type_implementation sourcefile outputprefix modulename initial_env ast =
         try
           find_in_path_uncap !Config.load_path (modulename ^ ".cmi")
         with Not_found ->
-          raise(Error(Location.none, Interface_not_compiled sourceintf)) in
+          raise(Error(Location.none, Env.empty,
+                      Interface_not_compiled sourceintf)) in
       let dclsig = Env.read_signature modulename intf_file in
       let coercion = Includemod.compunit sourcefile sg intf_file dclsig in
       Typecore.force_delayed_checks ();
@@ -1318,7 +1325,8 @@ let package_units objfiles cmifile modulename =
          let sg = Env.read_signature modname (pref ^ ".cmi") in
          if Filename.check_suffix f ".cmi" &&
             not(Mtype.no_code_needed_sig Env.initial sg)
-         then raise(Error(Location.none, Implementation_is_required f));
+         then raise(Error(Location.none, Env.empty,
+                          Implementation_is_required f));
          (modname, Env.read_signature modname (pref ^ ".cmi")))
       objfiles in
   (* Compute signature of packaged unit *)
@@ -1329,7 +1337,8 @@ let package_units objfiles cmifile modulename =
   let mlifile = prefix ^ !Config.interface_suffix in
   if Sys.file_exists mlifile then begin
     if not (Sys.file_exists cmifile) then begin
-      raise(Error(Location.in_file mlifile, Interface_not_compiled mlifile))
+      raise(Error(Location.in_file mlifile, Env.empty,
+                  Interface_not_compiled mlifile))
     end;
     let dclsig = Env.read_signature modulename cmifile in
     Cmt_format.save_cmt  (prefix ^ ".cmt") modulename
@@ -1430,3 +1439,6 @@ let report_error ppf = function
         "The type %a in this module cannot be exported.@ " longident lid;
       fprintf ppf
         "Its type contains local dependencies:@ %a" type_expr ty
+
+let report_error env ppf err =
+  Printtyp.wrap_printing_env env (fun () -> report_error ppf err)
diff --git a/typing/typemod.mli b/typing/typemod.mli
index c339825..6db904d 100644
--- a/typing/typemod.mli
+++ b/typing/typemod.mli
@@ -63,6 +63,6 @@ type error =
   | Incomplete_packed_module of type_expr
   | Scoping_pack of Longident.t * type_expr
 
-exception Error of Location.t * error
+exception Error of Location.t * Env.t * error
 
-val report_error: formatter -> error -> unit
+val report_error: Env.t -> formatter -> error -> unit
diff --git a/typing/typetexp.ml b/typing/typetexp.ml
index aa8b7c6..7d2f0b5 100644
--- a/typing/typetexp.ml
+++ b/typing/typetexp.ml
@@ -35,7 +35,7 @@ type error =
   | Alias_type_mismatch of (type_expr * type_expr) list
   | Present_has_conjunction of string
   | Present_has_no_type of string
-  | Constructor_mismatch of type_expr * type_expr
+  | Constructor_mismatch of Env.t * type_expr * type_expr
   | Not_a_variant of type_expr
   | Variant_tags of string * string
   | Invalid_variable_name of string
@@ -413,7 +413,8 @@ let rec transl_type env policy styp =
           let ty = mkfield l f and ty' = mkfield l f' in
           if equal env false [ty] [ty'] then () else
           try unify env ty ty'
-          with Unify trace -> raise(Error(loc, Constructor_mismatch (ty,ty')))
+          with Unify trace ->
+            raise(Error(loc, Constructor_mismatch (env, ty,ty')))
         with Not_found ->
           Hashtbl.add hfields h (l,f)
       in
@@ -683,30 +684,29 @@ let report_error ppf = function
   | Unbound_row_variable lid ->
       fprintf ppf "Unbound row variable in #%a" longident lid
   | Type_mismatch trace ->
-      Printtyp.unification_error true trace
+      Printtyp.report_unification_error ppf trace
         (function ppf ->
            fprintf ppf "This type")
-        ppf
         (function ppf ->
            fprintf ppf "should be an instance of type")
   | Alias_type_mismatch trace ->
-      Printtyp.unification_error true trace
+      Printtyp.report_unification_error ppf trace
         (function ppf ->
            fprintf ppf "This alias is bound to type")
-        ppf
         (function ppf ->
            fprintf ppf "but is used as an instance of type")
   | Present_has_conjunction l ->
       fprintf ppf "The present constructor %s has a conjunctive type" l
   | Present_has_no_type l ->
       fprintf ppf "The present constructor %s has no type" l
-  | Constructor_mismatch (ty, ty') ->
-      Printtyp.reset_and_mark_loops_list [ty; ty'];
-      fprintf ppf "@[<hov>%s %a@ %s@ %a@]"
-        "This variant type contains a constructor"
-        Printtyp.type_expr ty
-        "which should be"
-        Printtyp.type_expr ty'
+  | Constructor_mismatch (env, ty, ty') ->
+      Printtyp.wrap_printing_env env (fun () ->
+        Printtyp.reset_and_mark_loops_list [ty; ty'];
+        fprintf ppf "@[<hov>%s %a@ %s@ %a@]"
+          "This variant type contains a constructor"
+          Printtyp.type_expr ty
+          "which should be"
+          Printtyp.type_expr ty')
   | Not_a_variant ty ->
       Printtyp.reset_and_mark_loops ty;
       fprintf ppf "@[The type %a@ is not a polymorphic variant type@]"
diff --git a/typing/typetexp.mli b/typing/typetexp.mli
index 0b6d09d..8743b32 100644
--- a/typing/typetexp.mli
+++ b/typing/typetexp.mli
@@ -48,7 +48,7 @@ type error =
   | Alias_type_mismatch of (Types.type_expr * Types.type_expr) list
   | Present_has_conjunction of string
   | Present_has_no_type of string
-  | Constructor_mismatch of Types.type_expr * Types.type_expr
+  | Constructor_mismatch of Env.t * Types.type_expr * Types.type_expr
   | Not_a_variant of Types.type_expr
   | Variant_tags of string * string
   | Invalid_variable_name of string
diff --git a/utils/clflags.ml b/utils/clflags.ml
index 0b3f6be..81573f3 100644
--- a/utils/clflags.ml
+++ b/utils/clflags.ml
@@ -45,6 +45,7 @@ and init_file = ref (None : string option)   (* -init *)
 and use_prims = ref ""                  (* -use-prims ... *)
 and use_runtime = ref ""                (* -use-runtime ... *)
 and principal = ref false               (* -principal *)
+and real_paths = ref false              (* -real-paths *)
 and recursive_types = ref false         (* -rectypes *)
 and strict_sequence = ref false         (* -strict-sequence *)
 and applicative_functors = ref true     (* -no-app-funct *)
diff --git a/utils/clflags.mli b/utils/clflags.mli
index 828b946..40e0014 100644
--- a/utils/clflags.mli
+++ b/utils/clflags.mli
@@ -42,6 +42,7 @@ val init_file : string option ref
 val use_prims : string ref
 val use_runtime : string ref
 val principal : bool ref
+val real_paths : bool ref
 val recursive_types : bool ref
 val strict_sequence : bool ref
 val applicative_functors : bool ref
-- 
1.7.10

